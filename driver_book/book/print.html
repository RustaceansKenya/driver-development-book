<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>driver development in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">INTRO</li><li class="chapter-item expanded "><a href="intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="intro/prerequisites.html"><strong aria-hidden="true">2.</strong> Prerequisites for the Book</a></li><li class="chapter-item expanded affix "><li class="part-title">UNDERSTANDING DRIVERS (theory)</li><li class="chapter-item expanded "><a href="understanding_drivers/understanding_drivers.html"><strong aria-hidden="true">3.</strong> Intro to Drivers</a></li><li class="chapter-item expanded "><a href="understanding_drivers/controlling_the_device_below.html"><strong aria-hidden="true">4.</strong> Role 1: Controlling the device below</a></li><li class="chapter-item expanded "><a href="understanding_drivers/providing_an_interface.html"><strong aria-hidden="true">5.</strong> Role 2: Providing an interface</a></li><li class="chapter-item expanded "><a href="understanding_drivers/types_of_drivers.html"><strong aria-hidden="true">6.</strong> Types of Drivers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Kernel and Driver Interaction mechanisms</div></li><li class="chapter-item expanded affix "><li class="part-title">BARE METAL PROGRAMMING</li><li class="chapter-item expanded "><a href="bare_metal/the_no_std_preface.html"><strong aria-hidden="true">8.</strong> No std preface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bare_metal/no_std/the_no_std_intro.html"><strong aria-hidden="true">8.1.</strong> No std</a></li><li class="chapter-item expanded "><a href="bare_metal/no_std/removing_std_lib.html"><strong aria-hidden="true">8.2.</strong> Disabling the Standard Library</a></li><li class="chapter-item expanded "><a href="bare_metal/no_std/pracs_1.html"><strong aria-hidden="true">8.3.</strong> Pracs 1</a></li><li class="chapter-item expanded "><a href="bare_metal/no_std/pracs_2.html"><strong aria-hidden="true">8.4.</strong> Pracs 2</a></li></ol></li><li class="chapter-item expanded "><a href="bare_metal/cross_compilation/cross_compilation.html"><strong aria-hidden="true">9.</strong> Cross-Compilation</a></li><li class="chapter-item expanded "><a href="bare_metal/linking/linking.html"><strong aria-hidden="true">10.</strong> Linking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bare_metal/linking/rusty_linkers.html"><strong aria-hidden="true">10.1.</strong> Rusty Linkers</a></li></ol></li><li class="chapter-item expanded "><a href="bare_metal/probing/probing_preface.html"><strong aria-hidden="true">11.</strong> Probing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bare_metal/probing/probing_theory_1.html"><strong aria-hidden="true">11.1.</strong> Probing Theory</a></li><li class="chapter-item expanded "><a href="bare_metal/probing/pracs.html"><strong aria-hidden="true">11.2.</strong> Probing Pracs</a></li><li class="chapter-item expanded "><a href="bare_metal/probing/udev.html"><strong aria-hidden="true">11.3.</strong> udev</a></li><li class="chapter-item expanded "><a href="bare_metal/probing/flashing.html"><strong aria-hidden="true">11.4.</strong> Flashing</a></li><li class="chapter-item expanded "><a href="bare_metal/probing/logging_and_monitoring/monitoring_1.html"><strong aria-hidden="true">11.5.</strong> Monitoring and Logging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bare_metal/probing/logging_and_monitoring/monitoring_2.html"><strong aria-hidden="true">11.5.1.</strong> draft_1</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.7.</strong> No-std testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Performance testing</div></li><li class="chapter-item expanded affix "><li class="part-title">ABSTRACTIONS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> MMIO programming</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="registers_and_mmio_programming.html"><strong aria-hidden="true">13.1.</strong> Registers and MMIO programming</a></li></ol></li><li class="chapter-item expanded "><a href="knowing_your_hardware.html"><strong aria-hidden="true">14.</strong> The datasheet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Abstraction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="svd2rust.html"><strong aria-hidden="true">15.1.</strong> svd2rust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">THE UART THEORY</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Understanding UART Theory</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="uart_theory/draft_1.html"><strong aria-hidden="true">16.1.</strong> draft_1</a></li><li class="chapter-item expanded "><a href="uart_theory/draft_2.html"><strong aria-hidden="true">16.2.</strong> draft_2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Understanding UART physical Implemetation in the esp32</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (naive, without async)</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> tutorial over a naive UART implementation on a Qemu device</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (less naive, with async)</li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> tutorial over a naive UART implementation on a Qemu device</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">OTHER STORIES</li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Driver Security</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">22.1.</strong> Common Security Issues in Driver Development</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.2.</strong> Rust's Safety Features for Driver Security</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.3.</strong> Best Practices for Secure Driver Development</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Case Studies and Examples</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Real-world Driver Development Examples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Analyzing an Existing Rust Driver</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Iterative Implementation</div></li><li class="chapter-item expanded affix "><li class="part-title">APPENDIX</li><li class="chapter-item expanded "><a href="notable_crates.html"><strong aria-hidden="true">25.</strong> Notable Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Notable Learning Resources</div></li><li class="chapter-item expanded "><a href="why_embedded_rust.html"><strong aria-hidden="true">27.</strong> why use Rust?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Out of topic</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="misc/different_std_libs.html"><strong aria-hidden="true">28.1.</strong> different_std_libs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">driver development in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustaceansKenya/driver-development-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>This book is on driver development using Rust. You get to procedurally write a UART driver for a RISCV chip called ESP32C3.</p>
<p>The chip costs less than 8 dollars, kindly... politely...with utmost humility... burn that cash. BURN THAT CAAAASHHH!!! Money machine go BRRRR!!!</p>
<h3 id="why-the-uart"><a class="header" href="#why-the-uart">Why the UART?</a></h3>
<p>The UART driver was chosen because it is simple and hard at the same time. Both a beginner and an experienced folk can learn a lot while writing it.<br />
For example, the beginner can write a minimal UART and concentrate on understanding the basics of driver development; No-std development,linking, flashing, logging, abstracting things in a standard way, interrupt and error-handling...<br />
The pseudo_expert on the other hand can write a fully functional concurrent driver while focusing on things like performance optimization,concurrency and parallelism.</p>
<p>A dev can iteratively work on this one project for a long time while improving on it and still manage to find it challenging on each iteration. You keep on improving.</p>
<p>Moreover, the UART is needed in almost all embedded devices that require some form of I/O; making it a necessary topic for driver developers.</p>
<p>The main aim here is to teach, not to create the supreme UART driver ever seen in the multiverse.</p>
<h3 id="what-this-book-is-not"><a class="header" href="#what-this-book-is-not">What this book is NOT</a></h3>
<p>This book does not explain driver development for a particular Operating System or Kernel. Be it Tock, RTOSes, Windows or linux. This book assumes that you are building a generic driver.</p>
<h3 id="quick-links"><a class="header" href="#quick-links">Quick links</a></h3>
<p>To access the tutorial book, visit : <a href="https://rustaceanskenya.github.io/driver-development-book/">this link</a><br />
To access the source-code, visit <a href="https://github.com/RustaceansKenya/driver-development-book/tree/master/driver_code">this repo's sub-folder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites-for-the-book"><a class="header" href="#prerequisites-for-the-book">Prerequisites for the Book</a></h1>
<p>The prerequisites are not strict, you can always learn as you go:</p>
<ul>
<li>Computer architecture knowledge : you should have basic knowledge on things like RAM, ROM, CPU cycle, buses...</li>
<li>Rust knowledge : You don't have to be a generics or atomics guru. If you are okay with the topics covered before chapter 14 in the Rust book, then you are overqualified for this.</li>
<li>Have an esp32-c3. </li>
<li>Some interest in driver development.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-drivers"><a class="header" href="#intro-to-drivers">Intro to Drivers</a></h1>
<p>This chapter is filled with definitions.</p>
<p>And as you all know, there are NO right definitions in the software world. People still debate what 'kernel' means. People are okay using the word 'serverless' apps. It's chaos everywhere.</p>
<p>So the definitions used here are constrained in the context of this book.</p>
<h3 id="whats-a-driver"><a class="header" href="#whats-a-driver">What's a driver?</a></h3>
<p>A driver is a piece of software that sits in between a high-level program and a physical device. The high level program could be a kernel in this case. And the physical device could be an SSD disk attached to the motherboard.</p>
<p>The driver has 2 primary functions : </p>
<ol>
<li>Controlling the underlying device. (the SSD)</li>
<li>Providing an interface for the kernel/higher-level program to interact with. The interface could contain things like public functions, data_structures, message passing endpoints...</li>
</ol>
<p>Bird's view :<br />
<img src="understanding_drivers/img/birds_eye_view_upper.svg" alt="Alt text" /></p>
<p>Demo : 
<img src="understanding_drivers/img/birds_eye_view.svg" alt="Alt text" /></p>
<p>Let's break down the two main roles of the driver... </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-1--controlling-the-physical-device-below"><a class="header" href="#role-1--controlling-the-physical-device-below">Role 1 : Controlling the Physical device below</a></h1>
<p><strong>TLDR</strong> :<br />
The driver controls the hardware below by either <strong>Direct Register Programming</strong> or <strong>Memory Mapped Programming</strong>. This can be done in Assembly, low-level languages like C/Rust, or a mixture of both.</p>
<p>A physical device is a piece of electronic that does things, for example, an SSD disk stores data. You can read and write to that SSD device.</p>
<p>An SSD is roughly made up of : </p>
<ol>
<li>Storage cells</li>
<li>A small IC or processor that implements the SSD's firmware</li>
<li>The SSD's firmware stored in the SSD's ROM</li>
<li>Exposed registers</li>
</ol>
<p>The only way to interact with the device is through the exposed registers.</p>
<p>To make the device do things, you meaningfully supply electrical signals to the exposed registers. Once the CPU detects signals on the registers, it interprets them as parameters for the functions defined in the firmware. From there, the firmware does its duties.</p>
<p>Here is an extremely over-simplified and incorrect view of the SSD :</p>
<p><img src="understanding_drivers/img/ssd_stub.svg" alt="Alt text" /></p>
<p>Usage :</p>
<ol>
<li>To store data to the SSD...
<ol>
<li>You write an 8-bit address to the address register. This is called the 'destination address': it is the memory address of the place you want to write to in the SSD.</li>
<li>You write the 8-bit data that you wanted to store in the data register. This is called the 'subject data'</li>
<li>You make sure that the read register is not receiving any signal. This gets translated as 'read == false'.</li>
<li>You supply an electric signal to the write register. This electrical signal is translated as 'write == true'.</li>
<li>The SSD processor detects a signal in the 'write' register and immediately does the following : 
<ul>
<li>It starts executing the &quot;write function&quot; found in the firmware code. </li>
<li>It passes the 'destination' address and the 'subject data' to it</li>
<li>Viollah! The write operation is complete.</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="a-manual-driver"><a class="header" href="#a-manual-driver">A manual driver?</a></h3>
<p>If we had the ssd and a couple of electric wires only, we could store data without using a driver. All we have to do is to supply meaningful electric signals to the registers of the ssd.</p>
<p>For example, to store the number 1 into the address 0x05, we could do this... 
<img src="understanding_drivers/img/ssd_stub_manual_write.svg" alt="Alt text" /></p>
<h3 id="programming"><a class="header" href="#programming">Programming</a></h3>
<p>We are developers, we automate everything... especially when it is unnecessary. Our superpower.<br />
So how do we automate this manual manipulation of SSD registers? How?? Panic everywhere!!</p>
<p><em><strong>Solution 1: Direct Register Programming</strong></em></p>
<p>We attach all the SSD registers DIRECTLY to the CPU. And then write some assembly code to change the values of the attached registers...<br />
This solution gets the job done.</p>
<p>Demo: 
<img src="understanding_drivers/img/ssd_stub_register_programming.svg" alt="Alt text" /></p>
<p><em><strong>Solution 2: Memory Mapped Programming</strong></em><br />
The CPU has a limited number of registers. The RAM exists because of this exact reason.<br />
So instead of directly attaching the SSD registers to the limited CPU registers, we could attach them to the RAM instead.</p>
<p>We could then write some assembly code to manipulate RAM addresses, hence indirectly manipulating the values of the SSD registers. This is called Memory-mapped I/O programming (<strong>mmio programming</strong>).</p>
<p>This is the method that we will stick to because it is more practical.</p>
<p>You could however use Direct Register Programming when building things like pace-makers, nanobots or some divine machine that is highly specialized and requires 100% performance.</p>
<p>Here is a demo of a naive MMIO setup : 
<img src="understanding_drivers/img/ssd_stub_mmio_programming.svg" alt="Alt text" /></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>The driver controls the hardware below by either <strong>Direct Register Programming</strong> or <strong>Memory Mapped Programming</strong>. This can be done in Assembly, low-level languages like C/Rust, or a mixture of both.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-2-providing-an-interface"><a class="header" href="#role-2-providing-an-interface">Role 2: Providing an Interface</a></h1>
<p><strong>TLDR</strong></p>
<ul>
<li>Just provide a well-thought out API.</li>
<li>Err on the side of making communication between the kernel and the driver to be through message-passing.</li>
<li>Err on the side of exporting structures that implement singletons.</li>
</ul>
<p>One of the crucial aspects of driver development is designing a clear and concise API that effectively communicates the functionality of the driver to higher-level software components, such as the kernel or user-space applications. A well-thought-out API not only simplifies the integration of the driver into larger systems but also enhances its reusability across different projects.</p>
<h2 id="principles-of-a-good-driver-api"><a class="header" href="#principles-of-a-good-driver-api">Principles of a Good Driver API</a></h2>
<h3 id="1-clarity-and-consistency"><a class="header" href="#1-clarity-and-consistency">1. Clarity and Consistency</a></h3>
<p>The API should be intuitive and easy to understand, even for developers who are unfamiliar with the underlying hardware. Naming conventions, function signatures, and data structures should be consistent throughout the API to minimize confusion and improve readability.</p>
<h3 id="2-abstraction-of-complexity"><a class="header" href="#2-abstraction-of-complexity">2. Abstraction of Complexity</a></h3>
<p>The API should abstract away the low-level details of hardware interaction, providing a high-level interface that hides the intricacies of device communication. This allows software developers to focus on the task at hand without getting bogged down by hardware-specific implementation details.</p>
<h3 id="3-modularity-and-extensibility"><a class="header" href="#3-modularity-and-extensibility">3. Modularity and Extensibility</a></h3>
<p>A well-designed API should be modular and extensible, allowing developers to add new features or support additional hardware configurations without major modifications to existing code. Modular design promotes code reuse and simplifies maintenance over time.</p>
<h3 id="4-error-handling-and-robustness"><a class="header" href="#4-error-handling-and-robustness">4. Error Handling and Robustness</a></h3>
<p>Effective error handling is essential for a reliable driver API. Error codes, return values, and error reporting mechanisms should be clearly defined and well-documented to facilitate debugging and troubleshooting.</p>
<h2 id="communication-patterns"><a class="header" href="#communication-patterns">Communication Patterns</a></h2>
<p>When designing the interface between the kernel and the driver, it's essential to choose the most appropriate communication pattern based on the requirements of the system. While there are various communication mechanisms available, such as function calls, callbacks, and shared memory, message passing is often preferred for its simplicity and reliability.</p>
<h3 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h3>
<p>Message passing involves sending structured data packets, or messages, between the kernel and the driver. This decouples the communication process from the underlying implementation details, making it easier to maintain and debug. Furthermore, message passing promotes a clear separation of concerns between the kernel and the driver, enhancing system stability and security.</p>
<h3 id="singleton-structures"><a class="header" href="#singleton-structures">Singleton Structures</a></h3>
<p>In many cases, it's beneficial to export structures from the driver that implement the singleton pattern. Singleton structures represent a single instance of a particular resource or configuration, ensuring that there is only one instance of the structure across the system. This simplifies resource management and prevents conflicts or inconsistencies that may arise from multiple instances attempting to access the same resource simultaneously.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-of-drivers"><a class="header" href="#types-of-drivers">Types of Drivers</a></h1>
<p>Classifications and fancy words do not matter, we go straight to the list :</p>
<h2 id="drivers-classified-by-the-level-of-how-close-to-the-metal"><a class="header" href="#drivers-classified-by-the-level-of-how-close-to-the-metal">Drivers classified by the level of 'how close to the metal?'</a></h2>
<ol>
<li>
<p><strong>Function drivers</strong> : this drivers implement functions that directly manipulate registers. You could say that this are the OG drivers. </p>
</li>
<li>
<p><strong>Filter drivers/ Processing drivers/ Wrapper drivers</strong>: This drivers take input from the function drivers and process them into palatable input and functions for the kernel. They can be seen as 'adapters' between the function-driver and the kernel. They can even be used to implement additional security features. Point being, their main function is wrapping the function-driver.</p>
</li>
</ol>
<p>Oh look... this 👇🏻 is what we were talking about... thanks windows for your docs.<br />
<img src="understanding_drivers/img/types_of_drivers.png" alt="Alt text" /><br />
This image was borrowed from the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/what-is-a-driver-">Windows Driver development docs</a></p>
<p><strong>Note</strong> : <em>A driver stack</em> is a collection of different drivers that work together to achieve a common goal. For example, you may use many function and filter drivers to control an integrated piece of hardware.<br />
Another example : You may use a couple of filter drivers when porting a function driver to a new kernel environment.</p>
<h2 id="drivers-classified-by-function"><a class="header" href="#drivers-classified-by-function">Drivers classified by function</a></h2>
<ul>
<li>storage drivers : eg ssd drivers</li>
<li>File System Drivers : Drivers above the file system.</li>
<li>system drivers : used in motherboard components instead of peripherals</li>
<li>Input Device Drivers</li>
<li>Network Drivers</li>
<li>Communication drivers</li>
<li>Virtual drivers (Emulators)</li>
<li>This list can be as long as one can imagine... but I hope you get the drift</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bare-metal-programming"><a class="header" href="#bare-metal-programming">Bare Metal Programming</a></h1>
<p>Bare Metal Programming !!!!!!!!!!</p>
<p>Welcome to the first cool chapter.</p>
<p><a href="bare_metal/(https://os.phil-opp.com/)">Philipp Oppermann's blog</a> covered this chapter very well. You can read it here 👇🏽: </p>
<ul>
<li>Chapter 1 : <a href="bare_metal/(https://os.phil-opp.com/freestanding-rust-binary/)">A Freestanding Rust Binary</a></li>
<li>Chapter 2 : <a href="bare_metal/(https://os.phil-opp.com/minimal-rust-kernel/)">A Minimal Rust Kernel</a></li>
</ul>
<p>It would be an <strong>understatement</strong> to call those 2 chapters legendary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-std"><a class="header" href="#no-std">No Std</a></h1>
<p>Most rust programs depend on the standard library by default, including that simple 'hello world' you once wrote. The standard library on the other hand is dependent on the underlying operaring system or execution environment.</p>
<p>Drivers provide an interface for the OS to use, meaning that the OS depends on drivers... as a result, you have to write the driver code without the help of the OS-dependent Standard Library. This paragraph sounds like a riddle ha ha... but you get the point... to write a driver, you have to forget about help from the typical std library. That std library depends on your driver code... that std library depends on you.</p>
<p>When software does not depend on the standard library, it is said to be a bare-metal program. It can just be loaded to memory and the physical CPU will execute it as it is.</p>
<p>Bare metal programming is the art of writing code that assumes zero or almost-zero hosted-environment. A hosted environment typically provides a language runtime + a system interface like POSIX.</p>
<p>We will procedurally create a bare metal program in the next few sub-chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h3>
<p>The standard library is a group of common function declarations that get called by applications that run on top of an OS.<br />
So each OS needs to provide implementations for all those common functions.</p>
<p>For example, the standard library declares the thread_spawn function. Linux OS provides an implementation of that function that is different from the Windows implementation... provided they all do the same thing.</p>
<p>So when you write drivers, you cannot use the standard library. But you can use the core-library.</p>
<p>Losing the std library means you forget about threads, files, heap memory, the network, random numbers, standard output, or any other features requiring OS abstractions or specific hardware. If you need them, you have to implement them yourself. The table below summarizes what you lose...</p>
<div class="table-wrapper"><table><thead><tr><th>feature</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>heap (dynamic memory)</td><td>*</td><td>✓</td></tr>
<tr><td>collections (Vec, BTreeMap, etc)</td><td>**</td><td>✓</td></tr>
<tr><td>stack overflow protection</td><td>✘</td><td>✓</td></tr>
<tr><td>runs init code before main</td><td>✘</td><td>✓</td></tr>
<tr><td>libstd available</td><td>✘</td><td>✓</td></tr>
<tr><td>libcore available</td><td>✓</td><td>✓</td></tr>
</tbody></table>
</div>
<p>* Only if you use the <code>alloc</code> crate and use a suitable allocator like <a href="https://github.com/rust-embedded/alloc-cortex-m">alloc-cortex-m</a>.</p>
<p>** Only if you use the <code>collections</code> crate and configure a global default allocator.</p>
<p>** HashMap and HashSet are not available due to a lack of a secure random number generator.</p>
<p>You can find lib-core's documentation <a href="bare_metal/no_std/(https://doc.rust-lang.org/core/)">here</a><br />
You can find the standard library's documentation <a href="https://doc.rust-lang.org/std/index.html">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pracs-1"><a class="header" href="#pracs-1">Pracs 1</a></h1>
<p>It is best to do things practically... you get error messages that engrain into you some PTSD.</p>
<h2 id="step-1-disabling-the-std-library"><a class="header" href="#step-1-disabling-the-std-library">Step 1: Disabling the Std library</a></h2>
<p>Go to your terminal and create a new empty project :</p>
<pre><code class="language-bash">cargo new hello_world --bin
</code></pre>
<p>By default, rust programs depend on the standard library. To disable this dependence, you add the 'no_std attribute' to your code. The code however switches to depending on the 'core' crate.</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]

fn main(){
    println!(&quot;Hello world!!&quot;);
}</code></pre></pre>
<p>If you run this code, you get 3 compilation errors. </p>
<ol>
<li>error: cannot find macro <code>println</code> in this scope</li>
<li>error: <code>#[panic_handler]</code> function required, but not found</li>
<li>error: unwinding panics are not supported without std</li>
</ol>
<h2 id="step-2-fixing-the-first-error"><a class="header" href="#step-2-fixing-the-first-error">Step 2: Fixing the first Error</a></h2>
<p>The <a href="https://doc.rust-lang.org/std/macro.println.html">println macro</a> is part of the standard library. That is why it cannot be found in the scope of the 'no_std' crate.<br />
To fix the first error, we remove the println line.</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]

fn main(){
    // println!(&quot;Hello world!!&quot;);
}</code></pre></pre>
<p>Two errors remain...</p>
<h2 id="step-3-fixing-the-second-and-third-error--theory"><a class="header" href="#step-3-fixing-the-second-and-third-error--theory">Step 3: Fixing the second and third error  (theory)</a></h2>
<p>This is going to be a short fix but with a lot of theory behind it.<br />
To solve it, we have to understand the <a href="bare_metal/no_std/(https://doc.rust-lang.org/core/#how-to-use-the-core-library)">core library requirements</a> first. </p>
<p>The core library functions and definitions can get compiled for any target, provided that the target provides definitions of certain linker symbols. The symbols needed are :</p>
<ol>
<li>memcpy, memmove, memset, memcmp, bcmp, strlen. </li>
<li>rust_begin_panic</li>
<li>rust_eh_personality (this is not a symbol, it is actually a <a href="https://os.phil-opp.com/freestanding-rust-binary/#the-eh-personality-language-item">language item</a>)</li>
</ol>
<p>In other words, you can write whatever you want for any supported ISA, as long as you link files that contain the definitions of the above symbols.</p>
<h3 id="1-memcpy-memmove-memset-memcmp-bcmp-and-strlen-symbols"><a class="header" href="#1-memcpy-memmove-memset-memcmp-bcmp-and-strlen-symbols">1. memcpy, memmove, memset, memcmp, bcmp and strlen symbols</a></h3>
<p>These are all symbols that point to memory routines.<br />
You need to provide to the linker the ISA code that implements the above routines.</p>
<p>When you compile Rust code for a specific target architecture (ISA - Instruction Set Architecture), the Rust compiler needs to know how to generate machine code compatible with that architecture. For many common architectures, such as x86, ARM, or MIPS, the Rust toolchain already includes pre-defined implementations of these memory routines. Therefore, if your target architecture is one of these supported ones, you don't need to worry about providing these definitions yourself.</p>
<p>However, if you're targeting a custom architecture or an architecture that isn't directly supported by the Rust toolchain, you'll need to provide implementations for these memory routines. This ensures that the generated machine code will correctly interact with memory according to the specifics of your architecture.</p>
<h3 id="2-the-rust_begin_panic-symbol"><a class="header" href="#2-the-rust_begin_panic-symbol">2. the rust_begin_panic symbol</a></h3>
<p>This symbol is used by Rust's panic mechanism, which is invoked when unrecoverable errors occur during program execution. Implementing this symbol allows the generated code to handle panics correctly.<br />
You could say that THIS symbol references the function that the Rust runtime calls whenever a panic happens.</p>
<p>This means that you have to... </p>
<ol>
<li>Define a function that acts as the overall panic handler. </li>
<li>Put that function in a file</li>
<li>Link that file with your driver code when compiling.</li>
</ol>
<p>For the sake of ergonomics, the cool rust developers provided a 'panic-handler' attribute that you can attach to a divergent function. You do not have to do all the linking vodoo. This has been demonstrated later on... do not worry if this statement did not make sense.</p>
<h3 id="3-the-rust_eh_personality"><a class="header" href="#3-the-rust_eh_personality">3. The rust_eh_personality</a></h3>
<p>When a panic happens, the rust runtime starts unwinding the stack so that it can free the memory of the affected stack variables. This unwinding also ensures that the parent thread catches the panic and maybe deal with it.</p>
<p>Unwinding is awesome... but complicated to implement without the help of the std library. <em>Coughs in soy-dev</em>.</p>
<p>The rust_eh_personality is a language item that defines how the rust runtime behaves if a panic happens : &quot;does it unwind the stack? How does it unwind the stack? Or does it just refuse to unwind the stack and instead just end program execution?</p>
<p>To set this language behaviour, we are faced with two solutions :</p>
<ol>
<li>Tell rust that it should not unwind the stack and instead, it should just abort the entire program.</li>
<li>Tell rust that it should unwind the stack... and then offer it a pointer to a function definition that clearly implements the unwinding process. (we are soy-devs, this option is completely and utterly off the table!!)</li>
</ol>
<h2 id="step-3something-fixing-the-third-error"><a class="header" href="#step-3something-fixing-the-third-error">Step 3.something: Fixing the third Error</a></h2>
<p>The remaining errors were ...</p>
<pre><code class="language-bash">error: `#[panic_handler]` function required, but not found

error: language item required, but not found: `eh_personality`
  |
  = note: this can occur when a binary crate with `#![no_std]` is compiled for a target where `eh_personality` is defined in the standard library
  = help: you may be able to compile for a target that doesn't need `eh_personality`, specify a target with `--target` or in `.cargo/config`

error: could not compile `playground` (bin &quot;playground&quot;) due to 2 previous errors
</code></pre>
<p>This is our third error...</p>
<pre><code class="language-bash">error: `#[panic_handler]` function required, but not found
</code></pre>
<p>This is our fourth...</p>
<pre><code class="language-bash">error: language item required, but not found: `eh_personality`
</code></pre>
<p>Just like you guessed, the third error occured because the 'rust_begin_panic symbol' has not been defined. We solve this by pinning a '#[panic_handler]' attribute on a divergent function that takes 'panicInfo' as its input. This has been demonstrated below. A divergent function is a function that never returns.</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]

use core::panic::PanicInfo;


#[panic_handler]
// you can name this function any name...it does not matter. eg the_voice_breaker_the_original_copy_the_one_and_only_HIM
// The function takes in a reference to the panic Info. 
// Kid, go read the docs in core::panic module. You're a super soldier.  
fn default_panic_handler(_info: &amp;PanicInfo) -&gt; !{
    loop {  
        // function does nothing for now, but this is where you write your magic //
        // This is where you typically call an exception handler, or call code that logs the error messages before aborting the program
        // The function never returns, this is an endless loop... it is a divergent function
      }
}


fn main(){
    // println!(&quot;Hello world!!&quot;);
}</code></pre></pre>
<p>Would you look at that... if you compile this program, you'll notice that the third compilation error is f* gone!!! Hapa ni wapi!? Mwalimu wa maths!?</p>
<p>[undone : remove this before you publish]</p>
<h2 id="step-4-fixing-the-fourth-error"><a class="header" href="#step-4-fixing-the-fourth-error">Step 4: Fixing the Fourth Error</a></h2>
<p>The fourth error states that the 'eh_personality' language item is missing.<br />
But it is missing because we have not declared it anywhere... we havent even defined a stack unwinding function. So we just configure our program to never unwind the stack, that way... defining the 'eh_personality' becomes optional.</p>
<p>We do this by adding the following lines in the cargo.toml file : </p>
<pre><code class="language-toml"># this is the cargo.toml file
[package]
name = &quot;driver_code&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[profile.release]
panic = &quot;abort&quot; # if the program panics, just abort. Do not try to unwind the stack

[profile.dev]
panic = &quot;abort&quot; # if the program panics, just abort. Do not try to unwind the stack
</code></pre>
<p>Now ... drum-roll... time to compile our program without any errors....</p>
<p>But then ... out of no-where, we get a new diferent error ... </p>
<pre><code class="language-bash">error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`
</code></pre>
<p>Aahh errors... headaches...<br />
But at least it is a new error. 🤌🏼🥹<br />
It's a new error guys!! 🥳💪🏼😎</p>
<!-- [undone] -->
<!-- - crt0 functions
- crt0 implemetations
- elf board support? How is it implemented?
- triple-targets
- what does target add command actually do and why
- Target support
- Adding custom targets



- THe boot process
- THe esp32 boot process
- Loaders : BIOS, UEFI, U-Boot SPL, CoreBoot
- Runtimes : UEFI, ATF(ARM TRUSTED FIRMWARE)
- BootLoaders : Uboot, Grub, Linux Boot
- firmware standards in the RISCV ISA
- Open SBI
- System V ABI

Bios :
- firmware that sets up environment fit to run a kernel on. It does the following
  - does a power-on-self-test
  - loads the boot loader to memory. The bootloader then loads the Kernel
- Source Material : https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf
- Multiboot standard -->
<!-- [undone: more info needed on these memory routines specifies as libcore requirements and their integration] -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="pracs-2"><a class="header" href="#pracs-2">Pracs 2</a></h1>
<p>At the end of the last sub-chapter, we got the following error : </p>
<pre><code class="language-bash">error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`
</code></pre>
<p>Before we solve it, we need to cover some theory... </p>
<h2 id="rust-init-code-theory"><a class="header" href="#rust-init-code-theory">Rust init code theory</a></h2>
<p>'init code' is the code that gets called before the 'main()' function is called. 'init code' is not a standard name, it is just an informal name, but I hope you catch the meaning here. It is the code that gets executed in preparation for the main function.</p>
<p><img src="bare_metal/no_std/img/init_code_birds_view.svg" alt="Alt text" /></p>
<p>To understand 'init code', we need to understand how programs get loaded. Here we go...</p>
<h3 id="understanding-program-flow-machine-boot"><a class="header" href="#understanding-program-flow-machine-boot">Understanding program flow; Machine boot.</a></h3>
<p>When the power button of a machine(laptop) is pressed, the following events occur (an inaccurate description): </p>
<ol>
<li>
<p>Power flows into the processor. The processor immediately begins the fetch-execute cycle. Exept that the first fetch occurs from the ROM where the firmware is.</p>
</li>
<li>
<p>So in short, the firmware starts getting executed. The firmware performs a power-on-self test. </p>
</li>
<li>
<p>The firmware then makes the CPU to start fetching instructions from the ROM section that contains the <strong>loader</strong>. The loader is a program that can copy a program from memory and paste it in the RAM in an orderly way. By orderly way I mean ... it sets up the stack, adds some stack-control code to the RAM, it then loads up the different sections of the program. If the program has <a href="https://www.youtube.com/watch?v=lWVQsld8hMI">overlays</a> - it loads up the code that implements overlay control too.<br />
Essentially, the loader can paste a program on the RAM in a <strong>complete</strong> way.</p>
</li>
<li>
<p>The loader loads the Bootloader onto the RAM.</p>
</li>
<li>
<p>The loader then makes the CPU to point to the RAM section where the Bootloader is situated.</p>
</li>
<li>
<p>The Bootloader on the other hand starts setting up the RAM sections in preparation for loading the kernel.</p>
</li>
<li>
<p>The Bootloader then copies the kernel onto the RAM and makes the CPU pointer to point to the entry point of the kernel. An entry-point is the memory address of the first instruction for any program.</p>
</li>
<li>
<p>The kernel then loads the apps that run on top of it...</p>
</li>
</ol>
<p><strong>Why are we discussing all these?</strong><br />
To show that programs get executed ONLY because : </p>
<ol>
<li>
<p>They were loaded onto either the ROM or the RAM in a <strong>complete</strong> way. The stacks control, overlay-control and other control code routines were also copied onto the RAM together with the actual subject program. The action of copying 'control' code onto the RAM is part of <strong>Setting up the environment</strong> before program execution starts.</p>
</li>
<li>
<p>The CPU's instruction pointer happened to point to the <strong>entry point</strong> of the loaded program. An entry-point is the memory address of the first instruction for a certain program.</p>
</li>
</ol>
<h3 id="loading-a-rust-program"><a class="header" href="#loading-a-rust-program">Loading a Rust Program</a></h3>
<p>From the previous discussion, it became clear that to properly load a program, you have to setup its environment and identify its entrypoint.</p>
<p>A typical Rust program that depends on the std library depends on a program called 'crt0' to setup its initial environment. 'crt0' is sometimes called 'the C runtime Zero'. The 'crt0' then transfers control to the 'Rust-runtime'. The rust-runtime does its thing and then it finally calls the usual 'main' function.</p>
<p><img src="bare_metal/no_std/img/init_code_level_2.png" alt="Alt text" /><br />
This is the <strong>normal entry point chain</strong>. ☝🏼</p>
<h3 id="crt0-c-runtime"><a class="header" href="#crt0-c-runtime">CRT0 (C runtime)</a></h3>
<p>So what does the C runtime actually do?<br />
What does setting up the environment mean?<br />
What does runtime support mean?</p>
<p>Read about it <a href="bare_metal/no_std//src/misc/the_C_runtime.html">here</a></p>
<h3 id="the-rust-runtime"><a class="header" href="#the-rust-runtime">The Rust Runtime</a></h3>
<p>The entry-point of the Rust runtime is marked by the <strong>'start' language item</strong>.<br />
Rust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic. The runtime then finally calls the main function.</p>
<h2 id="fixing-the-error"><a class="header" href="#fixing-the-error">Fixing the Error</a></h2>
<p>To save you some scrolling time, here is the error we are trying to fix.</p>
<pre><code class="language-bash">error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`
</code></pre>
<p>This error occurs because we have not specified the entrypoint chain of our program.<br />
If we had used the std library, the default entry-point chain could have been chosen automatically ie the entry point could have been assumed to be the 'start' symbol that directly references the Rust runtime entrypoint.</p>
<p>To tell the Rust compiler that we don’t want to use the normal entry point chain, we add the '#![no_main]' attribute. Here's a demo : </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_std]
#[no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn default_panic_handler(_info: &amp;PanicInfo) -&gt; !{
    loop { /* magic goes here */ }
}

// main has just been trashed... coz... why not? It's pointless
<span class="boring">}</span></code></pre></pre>
<p>But when we compile this, we get a linking error, something like this ...</p>
<pre><code class="language-bash">error: linking with `cc` failed: exit status: 1
  |
  # some lines have been hidden here for the sake of presentability...   
<span class="boring">  = note: LC_ALL=&quot;C&quot; PATH=&quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/bin:/home/k/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin&quot; VSLANG=&quot;1033&quot; &quot;cc&quot; &quot;-m64&quot; &quot;/tmp/rustcWMxOew/symbols.o&quot; &quot;/home/k/ME/Repos/embedded_tunnel/driver-development-book/driver_code/target/debug/deps/driver_code-4c11dfa3f10db3d0.f20457jvl65bh2w.rcgu.o&quot; &quot;-Wl,--as-needed&quot; &quot;-L&quot; &quot;/home/k/ME/Repos/embedded_tunnel/driver-development-book/driver_code/target/debug/deps&quot; &quot;-L&quot; &quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib&quot; &quot;-Wl,-Bstatic&quot; &quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustc_std_workspace_core-9686387289eaa322.rlib&quot; &quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcore-632ae0f28c5e55ff.rlib&quot; &quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcompiler_builtins-3166674eacfcf914.rlib&quot; &quot;-Wl,-Bdynamic&quot; &quot;-Wl,--eh-frame-hdr&quot; &quot;-Wl,-z,noexecstack&quot; &quot;-L&quot; &quot;/home/k/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib&quot; &quot;-o&quot; &quot;/home/k/ME/Repos/embedded_tunnel/driver-development-book/driver_code/target/debug/deps/driver_code-4c11dfa3f10db3d0&quot; &quot;-Wl,--gc-sections&quot; &quot;-pie&quot; &quot;-Wl,-z,relro,-z,now&quot; &quot;-nodefaultlibs&quot;
</span>  = note: /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
          (.text+0x1b): undefined reference to `main'
          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'
          collect2: error: ld returned 1 exit status
          
  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified
  = note: use the `-l` flag to specify native libraries to link
  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)
</code></pre>
<p>This error occurs because the toolchain thinks that we are compiling for our host machine... which in this case happens to be a x86_64-unknown-linux-gnu machine.</p>
<p>To fix this error, we execute one of the following solutions :</p>
<ol>
<li>Specify a cargo-build for a triple target that has 'none' in its OS description. eg <code>riscv32i-unknown-none-elf</code>. This is the easier of the two solutions, and it is the most flexible.</li>
<li>Supply a new linker script that defines our custom entry-point and section layout. If this method is used, the build process will still treat the host's triple-target as the compilation target.</li>
</ol>
<p>If the above 2 paragraphs made complete sense to you, and you were even able to implement them, skip to the <a href="bare_metal/no_std/">Debugging chapter</a> <!-- undone: provide link --></p>
<p>If they did not make sense, then you got some reading to do in the next immediate chapters... <code>Cross compilation and linking</code>.<br />
Don't worry, we will get to a point where our bare-metal code will run without a hitch... but it's a long way to go. And its fun. Rainbows, uniorns and excalibars everywhere!!</p>
<!-- undone : explain the C runtime in more detail -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<h2 id="normal-compilation"><a class="header" href="#normal-compilation">Normal Compilation</a></h2>
<p><strong>Compilation</strong> is the process of converting source code into machine code. For example, converting hello-world to machine code for either a x86 CPU or a Riscv Chip.</p>
<p>The compilation process for a single file roughly looks like this ...<br />
<img src="bare_metal/cross_compilation/img/compilation.png" alt="Alt text" /></p>
<p>When multiple files need to get compiled together, the linker gets introduced : 
<img src="bare_metal/cross_compilation/img/compilation_with_linking.png" alt="Alt text" /></p>
<h2 id="target"><a class="header" href="#target">Target</a></h2>
<p>If we are compiling program <code>x</code> to run on machine <code>y</code>, then machine <code>y</code> is typically referred to as the <code>Target</code>.</p>
<p>If we compile the hello-world for different targets, we may end up with object files that are completely different from each other in terms of file format and file content.<br />
This is because the format and contents of the object file are majorly affected by the following factors : </p>
<ol>
<li>The CPU Architecture of the target</li>
<li>The Vendor-specific implementations on both the software and hardware of the target machine.</li>
<li>The <strong>Execution environment</strong> on which the compiled program is supposed to run on. In most cases the Execution environment is usually the OS.</li>
<li>The <strong>ABI</strong> of the execution environment OR the object file format that is loadable in the execution environment. </li>
</ol>
<p>To find out how these 4 factors affect the object file, read <a href="bare_metal/cross_compilation//src/misc/target_factors.html">here</a>.</p>
<p>So people started describing targets based on the state of the above 4 factors. For example :</p>
<p><strong>Target x86_64-unknown-linux-gnu</strong> means that the target machine contains a x86 CPU, the vendor is unknown and inconsequential, the execution environment is an Operating system called Linux, the execution environment can interact with object files ONLY if they follow the GNU-ABI specification.</p>
<p><strong>Target riscv32-unknown-none-elf</strong> means that the target machine contains a Riscv32 CPU, the vendor is unknown and inconsequential, the execution environment is nothing but bare metal, the execution environment can interact with object files ONLY if they follow the elf specification.</p>
<p>People usually call this target specifications <strong>triple targets</strong>...<br />
Don't let the name fool you, some names contain 2 parameters, others 4 ... others 5.</p>
<p>The 'software world' has a 'naming' problem...once you notice it, you see it everywhere. For example, what is a toolchain? Is it a combination of the compiler, linker and assembler? Or do we throw in the debugger? or maybe even the IDE? What is an IDE?? Is a text Editor with plugins an IDE?? You see? Madness everywhere!!</p>
<h3 id="why-are-triple-target-definitions-important"><a class="header" href="#why-are-triple-target-definitions-important">Why are triple-target definitions important?</a></h3>
<p>Because they help you in choosing and configuring your compiler, assembler and linker.</p>
<p>For example, if you were planning to compile program <code>x</code> for a <code>x86_64-unknown-linux-gnu</code> target....</p>
<ol>
<li>You would look for a x86_64 compiler, and install it.</li>
<li>You would look for a x86_64 assembler, and install it. </li>
<li>You would then look for essential Linux system files that could be linked to your program. </li>
<li>You would look for a Linux implementation of the standard library</li>
<li>You would look for a linker that can output GNU-ABI-compliant object files</li>
<li>You would then configure all these tools and libraries to work together.</li>
</ol>
<p>This is a lot of work and stress. But rust has a solution to this.</p>
<h3 id="enter-target-specification"><a class="header" href="#enter-target-specification">Enter target specification</a></h3>
<p>The default Rust compiler is based on LLVM.<br />
So it is modular, it has a back-end and a fron-end.</p>
<p>You can make the compiler to compile for a specific target by simply running the command : </p>
<pre><code class="language-bash"># install the pre-configured back-end, there is no need for you to perform the 6 steps mentioned above
# This command does all of them... or rather, it modifies your already existing LLVM toolchain  
rustup target add x86_64-unknown-linux-gnu 

# cross-compile for any target whose backend has already been added
cargo build hello-world --target=x86_64-unknown-linux-gnu  
</code></pre>
<h3 id="cross-compilation-1"><a class="header" href="#cross-compilation-1">Cross-compilation</a></h3>
<p><em>The host machine</em> is the machine on which you develop and compile your software.<br />
<em>The target machine</em> is the machine that runs the compiled sotware.</p>
<p>Cross-compilation is the act of compiling a program for a target machine whose triple-target specification is different from the triple-target specification of the host machine.</p>
<h3 id="making-cross-compilation-easier-with-cargo"><a class="header" href="#making-cross-compilation-easier-with-cargo">Making cross-compilation easier with cargo</a></h3>
<p>Example case :<br />
We are compiling a program on a <code>x86_64-unknown-linux-gnu</code> machine. We intend to run the program on a <code>riscv32-unknown-none-elf</code> machine.</p>
<p>We could use the command-line like this... </p>
<pre><code class="language-bash">cargo build --target=riscv32-unknown-none-elf  
</code></pre>
<p>But this would require us to repeat a lengthy comand each time. To make work easier, we could instruct cargo to always compile for a certain triple-target within our cargo project.<br />
This is achieved by modifying the .cargo/config.toml file</p>
<pre><code class="language-bash"># This is the .cargo/config.toml file

[build]
target = riscv32-unknown-none-elf
</code></pre>
<p>So each time you want to build the project, you run the usual command ...</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>Cargo is an awesome tool, learn more about it in the <a href="https://doc.rust-lang.org/cargo/">Cargo Book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking"><a class="header" href="#linking">Linking</a></h1>
<p><strong>SOLID CHOICES</strong> :</p>
<p>Linking is a VERY fundamental topic.</p>
<p>It is best to learn it <strong>slowly</strong> and <strong>in full</strong> from the <a href="bare_metal/linking/linking.html#note-worthy-docs">docs</a>. It will be worth it; You will save yourself hundreds of hours in the future if you make the first read intentional. Be patient with yourself, restrain from skimming through the docs if it's your first time.</p>
<p>For this reason, this book will not spoil or water-down the purity of the <a href="bare_metal/linking/linking.html#note-worthy-docs">linking docs</a>.</p>
<p>This book will however :</p>
<ul>
<li>assume that you have read <a href="bare_metal/linking/linking.html#note-worthy-docs">the docs</a>.</li>
<li>Briefly explain LLD linker usage in Rust targets </li>
<li>Demonstrate how to fix the no-std linking error encountered in the previous chapter </li>
<li>Demonstrate how to build a full linker script for the Esp32c3 board. (found in a much ater chapter)</li>
</ul>
<h3 id="note-worthy-docs"><a class="header" href="#note-worthy-docs">Note-worthy docs</a></h3>
<ol>
<li>Start with this 3-minute video demonstrating the role of the linker from a high level.</li>
<li>Then move to this <a href="https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/5_GNUPro_Utilities/c_Using_LD/ldLinker_scripts.html">doc</a>. It is gentle, covers the basics and its short.</li>
<li>And finally finish it with this <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">more detailed docs</a>. The two most important pages there are on <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">memory description</a> and <a href="https://sourceware.org/binutils/docs/ld/REGION_005fALIAS.html">memory abstraction</a>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rusty-linkers"><a class="header" href="#rusty-linkers">Rusty Linkers</a></h1>
<p>This chapter assumes that you have understood the <a href="bare_metal/linking/../linking/linking.html#note-worthy-docs">LD docs</a></p>
<p>There are many linkers in existence. However the two dominant linkers are :</p>
<ol>
<li>The <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">LD linker</a> (also called the GNU linker)</li>
<li>The <a href="https://lld.llvm.org/">LLD linker</a> (also called the LLVM linker)</li>
</ol>
<p>The Rust toolchain is a modification of the LLVM toolchain, so it uses the LLVM linker by default. You can however configure it to use ld with the help of Cargo.</p>
<h2 id="subtle-but-important-differences"><a class="header" href="#subtle-but-important-differences">Subtle but important differences.</a></h2>
<h3 id="1-automatic-linker-script-generation"><a class="header" href="#1-automatic-linker-script-generation">1. Automatic linker-script generation.</a></h3>
<p>The ld linker ALWAYS requires a manually-defined linker script to function. The LLD (the LLD linker) doesn't always use a manually-defined linker script like LD (the GNU linker).</p>
<p>In many cases, LD.LLD can automatically generate linker scripts internally based on the target architecture, format, and other parameters specified during the linking process. This means that LD.LLD can handle the linking process without requiring an explicit linker script provided by the user.</p>
<p>However, LD.LLD does provide options to allow users to specify custom linker scripts if needed. Users can pass a custom linker script to LD.LLD using command-line options or configuration files, similar to how it's done with LD. This gives users flexibility in defining the linking behavior and organizing the output binary according to their specific requirements.</p>
<h3 id="2-cross-linking-and-the-existence-of-flavours"><a class="header" href="#2-cross-linking-and-the-existence-of-flavours">2. Cross linking and the existence of flavours</a></h3>
<p>The ld linker is a monolith. There is only one ld linker. If you want to compile something into an elf, you supply the linker with an elf-generating linker script. If you need a wasm binary file, you supply it with a corresponding linker script.<br />
This may seem simple at first, but writing a correct linker script is usually not an easy task. To solve this problem, the LLVM linker implemented the concept of <em>ports</em> AND <em>flavours</em>.</p>
<p>The LLVM linker is not a monolith, it is made up of different specialized linkers within itself. These sub-linkers are called flavours.<br />
The flavours are linkers that are specialized in producing object files for supported targets. For example, Let's say you want to produce a unix elf file, instead of writing a complex &amp; erronous linker script, you use the LD.LLD linker flavour and it will automatically generate an internal script for you. This is what makes LLD a cross-linker by default.</p>
<p>There are currently 4 lld flavours : </p>
<ol>
<li>LD.LLD (unix) : specializes in generating object files and executables for Unix-like operating systems, such as Linux and FreeBSD. It supports formats like ELF (Executable and Linkable Format) and handles symbol resolution, linking libraries, and generating debug information specific to Unix environments.</li>
<li>ld64.lld (macOS) : secializes in producing object files and executables for macOS and other Apple platforms. It supports the Mach-O (Mach Object) file format used on macOS</li>
<li>lld-link (Windows) : specializes in generating object files and executables for Windows-based systems. It supports the PE (Portable Executable) file format used on Windows, handles symbol resolution, and integrates with Windows-specific tools and libraries for linking applications and generating executables compatible with the Windows environment.</li>
<li>wasm-ld (WebAssembly) : This flavour is a work in progress. It specializes in producing WebAssembly (Wasm) modules and executables that follow wasm specifications.</li>
</ol>
<h2 id="implications-of-those-subtle-differences"><a class="header" href="#implications-of-those-subtle-differences">Implications of those subtle differences</a></h2>
<p>Adding a target using the <code>rustup target add</code> literally adds a LLVM back-end that includes an LLD-flavour configured for the subject target. Declaring linker scripts is optional.</p>
<p>To view the defult lld flavour of a supproted target, run the following command :</p>
<pre><code class="language-bash"># Replace `riscv32i-unknown-none-elf` with a target of your liking
rustc -Z unstable-options --target riscv32i-unknown-none-elf --print target-spec-json
</code></pre>
<p>Feedback : </p>
<pre><code class="language-bash">{
  &quot;arch&quot;: &quot;riscv32&quot;,
  &quot;atomic-cas&quot;: false,
  &quot;cpu&quot;: &quot;generic-rv32&quot;,
  &quot;crt-objects-fallback&quot;: &quot;false&quot;,
  &quot;data-layout&quot;: &quot;e-m:e-p:32:32-i64:64-n32-S128&quot;,
  &quot;eh-frame-header&quot;: false,
  &quot;emit-debug-gdb-scripts&quot;: false,
  &quot;features&quot;: &quot;+forced-atomics&quot;,
  &quot;is-builtin&quot;: true,
  &quot;linker&quot;: &quot;rust-lld&quot;,  # HERE is the linker name... it could have been something like ld
  &quot;linker-flavor&quot;: &quot;gnu-lld&quot;,  # HERE is the linker Flavour
  &quot;llvm-target&quot;: &quot;riscv32&quot;,
  &quot;max-atomic-width&quot;: 32,
  &quot;panic-strategy&quot;: &quot;abort&quot;,
  &quot;relocation-model&quot;: &quot;static&quot;,
  &quot;target-pointer-width&quot;: &quot;32&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probing"><a class="header" href="#probing">Probing</a></h1>
<p>Probing is the act of interacting with the microcotroller via a debug adapter with the aim of doing at least one of the following... </p>
<ol>
<li>Flashing a compiled program onto the RAM or ROM of the microcontroller.</li>
<li>Performing some In-system programming</li>
<li>Debugging the running program</li>
<li>Testing the functionality of the microcrontroller</li>
</ol>
<p>This chapter walks through the first 3 tasks while assuming that...</p>
<ul>
<li>Your host machine is a linux box</li>
<li>Your target machine is an esp32c3 SoC.</li>
</ul>
<p>This chapter has also been divided into two :</p>
<ul>
<li>The theory behind probing</li>
<li>The practicals</li>
</ul>
<p>You choose how you'd like to read through it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probing-theory"><a class="header" href="#probing-theory">Probing Theory</a></h1>
<p>What is probing really? How is it achieved? What's flashing? What's in-system programming? Debugging?</p>
<h2 id="probing-1"><a class="header" href="#probing-1">Probing</a></h2>
<p>Probing is the act of interacting with a microcontroller... or a device that does not have a comprehensive User Interface.<br />
<img src="bare_metal/probing/img/probe_scifi.png" alt="Alt text" /></p>
<p>Interacting may mean one of the following :</p>
<ol>
<li><strong>In-system programming</strong> - this is the process of accessing the RAM and ROM of components in the SoC in such a way that you can change the firmware code.</li>
<li><strong>Monitoring</strong> - this is the act of fetching data on the events happening in the SoC for the sake of maybe debugging.</li>
<li><strong>Flashing</strong> - Flashing is a fancy name for : &quot;using in-system programming to wipe out all the current firmware in the memory and replacing them with fresh new lines&quot;</li>
<li><strong>SoC testing</strong> (eg boundary scan testing) - this is the act of testing whether the circuitry of the SoC works as expected.</li>
</ol>
<h2 id="how-are-probing-devices-able-to-interact-with-a-chip"><a class="header" href="#how-are-probing-devices-able-to-interact-with-a-chip">How are probing devices able to interact with a chip?</a></h2>
<p>&quot;A probing device is able to interact with a chip because the probe device interfaces with the boundary-scan interface present on the chip.&quot;</p>
<p>An SoC is made up of circuits. To test whether the circuits worked as exected, the designers of the past used to use <a href="https://en.wikipedia.org/wiki/Test_fixture">test fixtures</a> but with time they settled for using on-chip test circuits.<br />
An popular and standard example of on-chip test circuitry is the <a href="https://www.youtube.com/watch?v=Y_dfg8h_yEY">Boundary-scan</a>.</p>
<p>With time, it became clear that boundary scans could control and affect how the SoCs worked if connected properly. They could even be used to read and write to the RAM and ROM if attached to the DMA controller. They could be used to monitor the signals coming in and out of the Core. They could be used to inject stub data to the pins of the core and thus manipulate the core itself... Boundary-scans became the holy-grail of monitoring and manipulating SoCs.</p>
<p>With time people came up with boundary scan standards that roughly specified : </p>
<ul>
<li>How the circuitry was hooked up. </li>
<li>How the physical interface between the scan and external probes was to b implemented. </li>
<li>The communication protocol between the scan and external probes.</li>
</ul>
<p>One open and stadardized boundary scan is called the JTAG standard.<br />
There is also another proprietary on-chip test circuitry called SWD.</p>
<p>All this info might not make sense on the go...<br />
Go watch this <a href="https://www.youtube.com/watch?v=TlWlLeC5BUs">video by EEVBlog</a>, it puts things into persective.</p>
<p>After that <a href="https://www.youtube.com/watch?v=TlWlLeC5BUs">video</a>, you might want to get your definitions and structures right by reading a more <a href="https://www.xjtag.com/about-jtag/jtag-a-technical-overview/">formal but simple technical guide</a> by the xjtag organization.</p>
<p>By the end of all that reading and video-watching, the figure below should make total sense... in fact, you should be very very mad because it misses out on some important components :</p>
<p><img src="bare_metal/probing/img/jtag-registers.jpg" alt="Alt text" /></p>
<h2 id="the-probe-debug-adapter"><a class="header" href="#the-probe-debug-adapter">The Probe/ Debug Adapter</a></h2>
<p>From here on, the term JTAG will be used a synonym for Boundary-scan-circuit.</p>
<p>The probe/debug adapter is the physical device that connects a normal computer to the JTAG interface. This is because the JTAG interface is not directly compatible to the ports found on a normal computer. For example the USB port found on a computer cannot directly connect to the 4 pins of the JTAG port.</p>
<p><img src="bare_metal/probing/img/probe-core.png" alt="Alt text" /></p>
<h2 id="open-ocd-and-its-alternatives"><a class="header" href="#open-ocd-and-its-alternatives">Open-OCD and its alternatives</a></h2>
<p>So how does the host computer know which signals to send to the Debug adapter?</p>
<p>There is a program called OpenOCD. OpenOCD is a software abstraction of the JTAG protocol. This software program consumes high-level debug commands and outputs JTAG-level commands through the USB port.</p>
<p>From there, the drivers found in the debug adapter convert those USB-wrapped-JTAG-electrical signals into a 4-split output as shown below :</p>
<p><img src="bare_metal/probing/img/openocd-probe-core%20.png" alt="Alt text" /></p>
<p>There are many alternatives to OpenOCD... eg Probe-rs and SJLink. OpenOCD was used here just because it is a popular and battle-tested software. So whenever we mention OpenOCD, we are indirectly referring to all the JTAG-protocol software implementations; it is inaccurate but convenient.</p>
<p>Just to clarify, the high level commands that get consumed by OpenOCD do not necessarily have to come from the GDB debugger, they can come from any software that can interface with the API. For example 'flashing programs' and 'Monitoring programs' can also apply here... even well interfaced bash scripts are allowed!</p>
<h2 id="gdb-and-its-alternatives"><a class="header" href="#gdb-and-its-alternatives">GDB and its alternatives</a></h2>
<p>GDB (GNU Debugger) is a debugging software that has a well defined debugging protocol. There are many other debugging software and corresponding protocols... but we'll stick to GDB because it is has great support, well documented and it has many functionalities. It is battle-tested.</p>
<p>There are three modules of the GDB that are worth noting here : </p>
<ol>
<li>The GDB main application (mostly a CLI, but there are GUI implementions too)</li>
<li>The gdb server</li>
<li>The gdb stub</li>
</ol>
<p><strong>The GDB CLI</strong> is the core application, the engine. It is interactive and complete.</p>
<p><strong>The gdb server</strong> is a proxy between GDB CLI and other applications. Its main roles are :</p>
<ul>
<li>Listening &amp; Receiving data/instructions from the GDB CLI</li>
<li>Listening &amp; Receiving data/instructions from the application that has been interfaced to the GDB CLI</li>
<li>Passing on received data to the opposite end of the channel.</li>
</ul>
<p><strong>The gdb stub</strong> the gdb stub has two meanings depending on the context. And before we define the meanings, we'll take a detour to understand a tiny part of how a debugger works.</p>
<h3 id="the-detour-how-a-debugger-works"><a class="header" href="#the-detour-how-a-debugger-works">The Detour: How a debugger works</a></h3>
<p>Suppose you are debugging program <code>x</code> on your linux machine... the debub program and program <code>x</code> will run as two seperate processes.</p>
<p><strong>Debugging Information:</strong><br />
When you compile a program with debugging information enabled, the compiler includes additional metadata in the executable binary. This metadata provides GDB with information about the source code, such as variable names, line numbers, function names, and the layout of the program's memory.</p>
<p><strong>Launching the Program:</strong><br />
To debug a program with GDB, you typically start GDB and specify the executable binary of the program as an argument.<br />
GDB loads the executable binary into memory (RAM) and prepares it for debugging. It also reads the debugging information embedded in the binary to understand the structure of the program.</p>
<p><strong>Injecting extra code</strong><br />
When you set debugging breakpoints, what GDB actually does is to insert 'control code' in the process x's RAM text section. Same case to the <code>continue</code> gdb instruction.</p>
<p>During execution, the program's code resides in memory, where it can be modified by the debugger for debugging purposes. This modification is temporary and does not alter the original program file on disk.</p>
<p>When GDB inserts a breakpoint or other debugging instruction, it's modifying the program's code in memory, not the original source code file. This modification allows the debugger to interrupt the program's execution at specific points and provide debugging information to the user without permanently altering the program itself.</p>
<h3 id="back-from-the-detour-defining-gdb-stub"><a class="header" href="#back-from-the-detour-defining-gdb-stub">Back from the Detour: Defining gdb stub</a></h3>
<p>In the normal debugging context (i.e in a non-embedded environment), the word gdb stub means 'a file that contains the implementations of the control code that usually gets injected by the debugger into the process' memory.</p>
<p>You can learn more about this from the <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_126.html">official gdb docs on stubs</a></p>
<p>In the embedded context, the gdb stub is a piece of firmware that implements the 'control code' that gets inserted in the process' memory. It also contains an implementation of code that allows it to communicate to the gdb server. This GDB stub is usually found on the target machine or the debub probe.</p>
<p>GDB stubs are commonly used in embedded systems for facilitating communication between the target device and the debugger.</p>
<!--  undone

## Summary Picture  
 draw a summary picture that shows the relations between : 
 - host computer
 - target SoC
 - Debug Adapter
 - openOCD
 - GDB cli, gdb server, gdb stub
 - jtag interface
 - jtag TAP
 - core
 - memories (RAM + ROM) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="probing-pracs"><a class="header" href="#probing-pracs">Probing Pracs</a></h1>
<p>These pracs will take you through the process of ... </p>
<ul>
<li>Configuring the interconnection between the host machine and the target board using udev</li>
<li>Configuring gdb-to-openOCD-to-chip for the sake of flashing and debugging.</li>
<li>Setting up defmt and RTT crate for chip monitoring and logging.</li>
<li>Setting up a no-std testing framework</li>
</ul>
<p>At the moment, this chapter is under development.<br />
So in the meantime, we will take a shortcut and use the esp-based tools that abstract away all the intricacies of manually setting things up.</p>
<p>Manually setting things up is a good way to learn, but we will take a curve just this one time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="udev"><a class="header" href="#udev">Udev</a></h1>
<p>Reference tutorial : https://opensource.com/article/18/11/udev</p>
<p>Udev stands for User-Device manager.<br />
It is one of linux's subsystems. You can find the other subsystems in the root folder '/sys'.<br />
Udev is the Linux subsystem that supplies your computer with device events.</p>
<p>When you plug in a device to your linux pc...</p>
<ul>
<li>The device gets detected by some of udev submodules.</li>
<li>The device gets abstracted as a file stored in the <code>/dev</code> root directory.</li>
<li>Udev starts and continues to act as a message proxy between the kernel and device. </li>
<li>Udev continuously listens and detects events induced by the external device and relays this info to the kernel.</li>
<li>The kernel on the other hand, returns action responses to udev. Udev then invokes the necessary action given by the kernel responses.</li>
</ul>
<p>The above description is somehow inaccurate and is given to provide a high-level overview of what happens. To read on the exact order and definitions of things, consult official udev docs.</p>
<h2 id="listing-attached-devices"><a class="header" href="#listing-attached-devices">Listing attached devices</a></h2>
<p>The process of detecting and abstracting attached devices as files in the <code>/dev</code> directory happens automatically.<br />
To view attached devices, you can browse through the <code>/dev</code> directory OR use the following cmd commands :</p>
<pre><code class="language-bash">lsusb# List all the devices that have been attached to the USB-controllers
lsblk # List all block devives

lscpu # List all CPUs
lspci # Lists all PCI devices
</code></pre>
<h3 id="reading-the-results-from-the-cmd-commands"><a class="header" href="#reading-the-results-from-the-cmd-commands">Reading the results from the cmd commands</a></h3>
<p>Here is an example of a reading :</p>
<pre><code class="language-bash">&gt; lsusb
Bus 001 Device 002: ID 8087:8001 Intel Corp. Integrated Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 0424:5534 Microchip Technology, Inc. (formerly SMSC) Hub
Bus 003 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 002 Device 004: ID 05c8:0374 Cheng Uei Precision Industry Co., Ltd (Foxlink) HP EliteBook integrated HD Webcam
Bus 002 Device 003: ID 8087:0a2a Intel Corp. Bluetooth wireless interface
Bus 002 Device 005: ID 0461:4d22 Primax Electronics, Ltd USB Optical Mouse
Bus 002 Device 002: ID 0424:2134 Microchip Technology, Inc. (formerly SMSC) Hub
Bus 002 Device 038: ID 04e8:6860 Samsung Electronics Co., Ltd Galaxy A5 (MTP)
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub

</code></pre>
<p>The above output depicts that...</p>
<ul>
<li>There are at least three USB controllers denoted by the term BUS [1 - 3]. Note that a USB-port is not synonymous to USB-controller.</li>
<li>The <code>Ltd USB Optical Mouse</code> has a device ID of <code>4d22</code></li>
<li>The <code>Ltd USB Optical Mouse</code> has a Vendor ID of <code>0461</code></li>
<li>The <code>Ltd USB Optical Mouse</code> has been attached USB-port 005 of the second USB-controller</li>
<li>The file that abstracts <code>Ltd USB Optical Mouse</code> is <code>/dev/bus/usb/002/005</code>.</li>
</ul>
<h2 id="udevs-real-time-monitoring-of-device-events"><a class="header" href="#udevs-real-time-monitoring-of-device-events">Udev's Real-time monitoring of device-events</a></h2>
<p>With the udevadm monitor command, you can tap into udev in real time and see what it sees when you plug in different devices. Become root and try it.</p>
<pre><code class="language-bash">&gt; sudo -i
&gt; udevadm monitor
</code></pre>
<p>The monitor function prints received events for:</p>
<ul>
<li>UDEV: the event udev sends out after rule processing</li>
<li>KERNEL: the kernel uevent</li>
</ul>
<p>With udevadm monitor running, plug in a thumb drive and watch as all kinds of information is spewed out onto your screen. Notice that the type of event is an ADD event. That's a good way to identify what type of event you want.</p>
<h2 id="udevs-info-snooping"><a class="header" href="#udevs-info-snooping">Udev's info snooping</a></h2>
<p>You can view the info for a particular device by using the command : <code>udevadm info [OPTIONS] [DEVPATH|FILE]</code>.<br />
For example : </p>
<pre><code class="language-bash"># suppose the lsusb command had the folowing output...
# Bus 002 Device 005: ID 0461:4d22 Primax Electronics, Ltd USB Optical Mouse
# Then you would get info about the mouse by...
udevadm info /dev/bus/usb/002/005
</code></pre>
<h2 id="udev-scripts"><a class="header" href="#udev-scripts">Udev scripts</a></h2>
<p>You can write scripts for udev. For example, you may automatically make your flash-drive trigger the execution of a bash script whenever it gets plugged in a specific usb-port.</p>
<p>In normal scripting/programming, you usually identify an object using something like a variable name. However, in udev scripting, you identify devices based on a set of attributes. The more specific the atributes, the more you narrow your reference to a specific device.</p>
<p>Here is a rough format of an instruction : </p>
<pre><code class="language-bash"># This is an exerpt from a udev script
# The following statement means ....
#  Whenever a USB device gets ADDed (plugged-in), the 'thumb' script gets ran
SUBSYSTEM==&quot;usb&quot;, DRIVER==&quot;usb&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/usr/local/bin/thumb
</code></pre>
<pre><code class="language-bash"># But this rule is more specific... it does not specify just a usb device, 
# it specifies the product ID and vendor ID of the device
SUBSYSTEM==&quot;usb&quot;, DRIVER==&quot;usb&quot;, ATTR{idProduct}==&quot;4d22&quot;,  ATTR{idVendor}==&quot;0461&quot;, ACTION==&quot;add&quot;, RUN+=&quot;/usr/local/bin/thumb_for_mouse
</code></pre>
<p>To find the specific attributes of a device and all of its parents, use the command below :</p>
<pre><code class="language-bash">udevadm info -a /dev/bus/usb/002/005
</code></pre>
<p>Udev fetches its scripts from <code>/etc/udev/rules.d/</code>.<br />
The script files end with the a <code>.rules</code> extension.<br />
The script files usually begin with a number to show the order in which the scripts get parsed by udev. For example <code>80-usb-script.rules</code> will get executed before <code>81-usb-extra-script.rules</code>.</p>
<h2 id="so-why-were-we-learning-about-udev"><a class="header" href="#so-why-were-we-learning-about-udev">So why were we learning about Udev?</a></h2>
<p>Well, two reasons...</p>
<ol>
<li>It's essential knowledge, especially if you'll be handling devices using the linux kernel.</li>
<li>We will need to interact with the device files. The problem is that the device files are only writable by <code>root</code>. So we need to make the files that we need accessible to our normal development account.</li>
</ol>
<h1 id="pracs"><a class="header" href="#pracs">Pracs</a></h1>
<ul>
<li>Attach your Esp32c3 to your computer using a usb cable.</li>
<li>You will notice that 2 new files get generated under the <code>/dev</code> directory. One under tty (eg ttyACM0) and one under <code>/dev/bus</code>. Figure out where and why. These 2 files are there to abstract your device and the USB connection. </li>
<li>Write a script to make these two files accessible to your linux account.</li>
</ul>
<p>Done!!</p>
<!-- undone, finish this udev tutorial -->
<!-- [undone: write a tutorial on udev]  
to remember : 
  - [ ] monitoring with 'udevadm monitor'. Looking out for verbs/actions associated with device. What is the order of events when device_event happens?
  - [ ] listing the available devices : lsusb, lsblk, lshw, 
  - [ ] Reading output from lsusb.
  - [ ] Reading output from lsblk.
  - [ ] Getting all associated attributes associated to a specific device and its parents, so as to get the right attributes to reference when writing rules
  - [ ] Writing rules.
  - [ ] Reloading rules
  - [ ] Logging -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="flashing"><a class="header" href="#flashing">Flashing</a></h1>
<p>In embedded development, &quot;flashing&quot; typically refers to the process of writing or programming the firmware or software onto a microcontroller or other embedded system's non-volatile memory. This non-volatile memory can be flash memory, EEPROM (Electrically Erasable Programmable Read-Only Memory), or similar types of memory that retain data even when power is removed.</p>
<p>We will use <a href="https://esp-rs.github.io/book/tooling/espflash.html">the esp-flash tool</a>. A tool purposefully built to flash programs into <code>esp</code> boards like our very own Esp32c3.</p>
<p>We could have used other tools like OpenOCD and Probe-rs because they are more generic than espflash. Once you learn them, you can tweak them for different platforms. Espflash is specialized, readers are advised to learn other tools in order to have a holisti growth.</p>
<p>We will use <a href="https://esp-rs.github.io/book/tooling/espflash.html">espflash</a> in order to escape the trouble of writing our own configs and flashing algorithm.</p>
<h2 id="the-honors-of-flashing-finally"><a class="header" href="#the-honors-of-flashing-finally">The honors of flashing... finally</a></h2>
<p>The <a href="https://github.com/esp-rs">esp-rs team</a> did a good job with <a href="https://esp-rs.github.io/book/">their docs</a>. Go through the <a href="https://esp-rs.github.io/book/tooling/espflash.html">flashing page</a> and do the honors. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring-and-logging"><a class="header" href="#monitoring-and-logging">Monitoring and Logging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draft_1"><a class="header" href="#draft_1">draft_1</a></h1>
<p>This page explains how we are going to achieve logging in our setup.</p>
<h2 id="typical-logging-architecture"><a class="header" href="#typical-logging-architecture">Typical logging architecture</a></h2>
<p>So how does logging happen? How is the log data encoded? How is the data transmitted? How does the host machine receive and display the log data?</p>
<p>Here is a rough architecture....</p>
<p><img src="bare_metal/probing/logging_and_monitoring/img/logging_architecture_lvl_0.png" alt="Alt text" /></p>
<p>Well... there's a lot to unpack here.</p>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registers-and-mmio-programming"><a class="header" href="#registers-and-mmio-programming">Registers and MMIO programming</a></h1>
<p>You know your hardware by reading the relevant parts of your datasheet.<br />
Your hardware is like a library, the datasheet is its documentation.</p>
<h2 id="mmio-programming"><a class="header" href="#mmio-programming">MMIO Programming</a></h2>
<p>But before we talk about the datasheets, let't talk about MMIO-programming.</p>
<!-- [demo, undone]   -->
<p>MMIO involves using memory addresses as an interface to communicate with and control hardware devices.</p>
<p>Memory-Mapped I/O refers to the technique of accessing hardware registers and controlling peripherals using memory addresses. Instead of specialized instructions, developers interact with hardware by reading from and writing to specific memory addresses, treating hardware like memory-mapped regions.</p>
<p>Hardware Registers: Peripherals and hardware components are often controlled by registers, each associated with a specific functionality (e.g., configuration, data transmission, status).</p>
<p>So to control hardware, you read and write to the respective registers... or memory regions.</p>
<h2 id="the-volatile-key-word"><a class="header" href="#the-volatile-key-word">The Volatile key word</a></h2>
<p>Quick detour :</p>
<p>Facts :</p>
<ol>
<li>Your code does not always get executed procedurally. </li>
<li>Some lines from your code get ignored or cut out by the compiler or CPU. </li>
</ol>
<p>The compiler optimizes the order of instructions, it even makes assumptions : 
eg </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let register_1 = 1;
  // insert other instructions here
  let register_1 = 1;
<span class="boring">}</span></code></pre></pre>
<p>can be optimized to </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let register_1 = 1;
  // insert other instructions here
  //   let register_1 = 1; // gets truncated
<span class="boring">}</span></code></pre></pre>
<p>The CPU also optimizes and changes the order of those instruction even further.<br />
If you add parallelism to the matter... it just makes it impossible to be sure that your instructions get executed in a specific order. </p>
<p>These optimizations are bad if the changes to the register truly matter.</p>
<h3 id="enter-the-volatile-key-word-the-superhero"><a class="header" href="#enter-the-volatile-key-word-the-superhero">Enter the volatile key-word... the superhero</a></h3>
<p>The volatile keyword makes reads and writes to be atomic and un-reordered(if that'ts a word).</p>
<p>It is the embodiement of :
&quot;Hey, compiler and CPU, no optimizations should affect the order of my reads and writes. I cannot deal with surprises please&quot;<br />
useul when the order and timing of reads and writes are critical, and the compiler should not make any assumptions about the potential side effects of these operations.</p>
<p>example in rust : </p>
<pre><pre class="playground"><code class="language-rust">// Import necessary modules
use core::ptr;

fn main() {
    // Define a mutable pointer to a memory-mapped address
    let mut mmio_ptr = 0x4000_0000 as *mut u32;

    unsafe {
        // Read from a volatile memory-mapped address
        let value = ptr::read_volatile(mmio_ptr);
        println!(&quot;Read value: {}&quot;, value);

        // Write to a volatile memory-mapped address
        let new_value = value + 1;
        ptr::write_volatile(mmio_ptr, new_value);
        println!(&quot;Written new value: {}&quot;, new_value);
    }
}</code></pre></pre>
<p>Summary :</p>
<ol>
<li>You control hardware by reading and writing to its registers.</li>
<li>All reads and writes to the registers have to be done using the volatile keyword.</li>
</ol>
<p>Question : Why do you think Volatile reads and writes are not the default methods. why are unpredictable reads and writes the default methods?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knowing-your-hardware"><a class="header" href="#knowing-your-hardware">Knowing your Hardware</a></h1>
<p>Your hardware is like a library, to use it correctly, you should know it well... or at least know the relevant parts.<br />
To understand your hardware, you read the datasheet. Like this one : the <a href="https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf">esp32 datasheet</a></p>
<p>The 20% of the 100%, the important parts :</p>
<ul>
<li>Understand the functional features and capabilities </li>
<li>Understand the hardware registers AND pins of the hardware you want to control.</li>
</ul>
<p>What's the diference between  pin and a register in mmio?</p>
<!-- [Demo, undone] -->
<h3 id="figures"><a class="header" href="#figures">Figures</a></h3>
<ol>
<li>
<p>Physical board with Pins
<img src="img/semiconductor_QFN.png" alt="Alt text" /></p>
</li>
<li>
<p>Pin Layout
<img src="img/pin_layout_1.png" alt="Alt text" />
<img src="img/pin_layout_2.png" alt="Alt text" /></p>
</li>
<li>
<p>Memory Layout (Registers + Actual_memory)
<img src="img/memory_mapping_1.png" alt="Alt text" />
<img src="img/memory_mapping_2.png" alt="Alt text" />
<img src="img/memory_mapping_3.png" alt="Alt text" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svd2rust"><a class="header" href="#svd2rust">svd2rust</a></h1>
<p>Once you read the datasheet, and understand the memory mapping, pin-layout and whatever else you wanted to get straight, you begin to safely abstract the board.</p>
<h3 id="svd-files"><a class="header" href="#svd-files">SVD files</a></h3>
<p>An svd file is a file that describes the peripherals of a board using xml. So you could say that an svd file is a board abstracted as an xml template.<br />
SVD is the abbreviation for : System View Description.</p>
<p>The svd file outlines :</p>
<ul>
<li>The boards metadata eg boardname, board version, feature description, vendor name</li>
<li>Major component info : eg CPU_capabilities, Endianness, address_width, added cpu_extensions... </li>
<li>all list of all the peripherals
<ul>
<li>the registers of each peripheral</li>
<li>the functions of each register</li>
<li>the memory address of each register</li>
<li>the read/write access of each register</li>
</ul>
</li>
</ul>
<p>You can find sample svd files <a href="%5Bhttps://github.com/espressif/svd/tree/main/svd%5D">here</a>, they are from the espressif organization.<br />
Here is the esp32C3 svd file that we will be using : <a href="%5Bhttps://github.com/espressif/svd/tree/main/svd%5D">ESP32_C3 svd file</a></p>
<p>Here is a snippet of a sample svd file : </p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;device schemaVersion=&quot;1.1&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xs:noNamespaceSchemaLocation=&quot;CMSIS-SVD_Schema_1_1.xsd&quot;&gt;
  &lt;vendor&gt;ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.&lt;/vendor&gt;
  &lt;vendorID&gt;ESPRESSIF&lt;/vendorID&gt;
  &lt;name&gt;ESP32-C3&lt;/name&gt;
  &lt;series&gt;ESP32 C-Series&lt;/series&gt;
  &lt;version&gt;17&lt;/version&gt;
  &lt;description&gt;32-bit RISC-V MCU &amp;amp; 2.4 GHz Wi-Fi &amp;amp; Bluetooth 5 (LE)&lt;/description&gt;

  &lt;!-- snip snip snipped some lines --&gt;

  &lt;cpu&gt;
    &lt;name&gt;RV32IMC&lt;/name&gt;
    &lt;revision&gt;r0p0&lt;/revision&gt;
    &lt;endian&gt;little&lt;/endian&gt;
    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;
    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;
    &lt;nvicPrioBits&gt;0&lt;/nvicPrioBits&gt;
    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;
  &lt;/cpu&gt;

  &lt;!-- snip snip snipped some lines --&gt;

   &lt;peripherals&gt;
   
   &lt;!-- here is 1/32 peripherals --&gt;
    &lt;peripheral&gt;
        &lt;name&gt;UART0&lt;/name&gt;
      &lt;description&gt;UART (Universal Asynchronous Receiver-Transmitter) Controller 0&lt;/description&gt;
      &lt;groupName&gt;UART&lt;/groupName&gt;
      &lt;baseAddress&gt;0x60000000&lt;/baseAddress&gt;
      &lt;addressBlock&gt;
        &lt;offset&gt;0x0&lt;/offset&gt;
        &lt;size&gt;0x84&lt;/size&gt;
        &lt;usage&gt;registers&lt;/usage&gt;
      &lt;/addressBlock&gt;
      &lt;interrupt&gt;
        &lt;name&gt;UART0&lt;/name&gt;
        &lt;value&gt;21&lt;/value&gt;
      &lt;/interrupt&gt;
      &lt;registers&gt;
        &lt;register&gt;
          &lt;name&gt;FIFO&lt;/name&gt;
          &lt;description&gt;FIFO data register&lt;/description&gt;
          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;
          &lt;size&gt;0x20&lt;/size&gt;
          &lt;fields&gt;
            &lt;field&gt;
              &lt;name&gt;RXFIFO_RD_BYTE&lt;/name&gt;
              &lt;description&gt;UART 0 accesses FIFO via this register.&lt;/description&gt;
              &lt;bitOffset&gt;0&lt;/bitOffset&gt;
              &lt;bitWidth&gt;8&lt;/bitWidth&gt;
              &lt;access&gt;read-write&lt;/access&gt;
            &lt;/field&gt;
          &lt;/fields&gt;
        &lt;/register&gt;

        &lt;!-- more registers --&gt;
        &lt;register&gt;
        &lt;/register&gt;
        &lt;/register&gt;
        &lt;!-- more registers --&gt;
    &lt;peripheral&gt;

    &lt;!-- snipped out the other 31 peripherals --&gt;
   &lt;peripherals&gt;
</code></pre>
<h3 id="svd2rust-1"><a class="header" href="#svd2rust-1">svd2Rust</a></h3>
<p>This is a tool that takes in svd files and outputs Rust code that reflects the contents of the svd file.</p>
<h3 id="why-use-svd2rust-instead-of-doing-the-abstraction-manually"><a class="header" href="#why-use-svd2rust-instead-of-doing-the-abstraction-manually">Why use svd2rust instead of doing the abstraction manually?</a></h3>
<p>Before we discuss whether you should do it manually or not. Let's settle out some facts first.<br />
A full-fledged board has many components. The datasheet reference is like &gt;700 pages. These components are dependent on each other.<br />
You get some form of info overload. How can you create complete abstractions if you do not fully understand the board and how they are interdependent on each other? Enter headaches and suicidal thoughts.</p>
<p>If you look at the esp32c3.svd file, you realize it is &gt;35000 lines. But at-least the svd file provides a complete abstraction from the &gt;700 page datasheet.</p>
<h4 id="when-to-do-it-manually"><a class="header" href="#when-to-do-it-manually">When to do it manually</a></h4>
<ol>
<li>When you fully understand all the details about a peripheral</li>
<li>When you also fuly understand all the direct components that the target peripheral depends on.</li>
<li>When you can comfortably abstract the peripheral and its dependents, in a safe way: critical sections, atomics and all that vodoo when accessing registers.</li>
<li>When you do not need to abstract the whole board.</li>
</ol>
<h4 id="when-to-do-it-automatically"><a class="header" href="#when-to-do-it-automatically">When to do it automatically</a></h4>
<ol>
<li>When you dont mind abstracting all the peripherals</li>
<li>When you want a library to automatically implement the access-safety methods of accessing registers. You don't have to implement atomic vodoo on your own.</li>
<li>When you want to use a standard way of abstracting the board. Your whole team uses the same template. Everyone speaks the same language, everyone becomes happy.</li>
</ol>
<h3 id="svd2rust-2"><a class="header" href="#svd2rust-2">svd2rust</a></h3>
<p>To understand svd2rust, let's :</p>
<ol>
<li>read its docs</li>
<li>experiment with it a little</li>
<li>Do our abstractions manually without depending on svd2rust</li>
<li>Go back to svd2rust while fully appreciating all the manual work it does for us </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draft_1-1"><a class="header" href="#draft_1-1">draft_1</a></h1>
<p>This chapter covers theory on the uart.</p>
<h2 id="what-is-the-uart"><a class="header" href="#what-is-the-uart">What is the UART?</a></h2>
<p>Before tackling the meaning of UART, let's get the acronyms out of the way.</p>
<ul>
<li>UART stands for <code>Universal Asynchronous Receiver/Transmitter</code>.</li>
<li><em>Tx</em> stands for <code>Transmitter</code>.</li>
<li><em>Rx</em> stands for <code>Receiver</code>.</li>
</ul>
<p>The UART is an integrated circuit that takes in parallel data from one end and outputs serial data on the other end. It also receives serial data from one end and outputs parallel data on the other end.</p>
<p>So it you connect two UARTs as seen below, you achieve serial communication between two devices that have parallel data buses.</p>
<p><img src="uart_theory/img/uart_connection.png" alt="Alt text" /></p>
<p><strong>What does asynchronous mean in this case?</strong><br />
&quot;Asynchronous&quot; refers to the method by which data is transmitted and received between two independent devices without requiring a shared clock signal between the transmitting and receiving devices.<br />
Instead of using a clock to synchronize the rate at rate at which bits are exchanged, the two communicating devices agree on the data-packet format and the rate of transmitting the bits of that data-packet.</p>
<p>The rate at which the bits of the data-packet are transmitted is referred to as <code>baud rate</code> in this context.</p>
<h3 id="so-is-uart-a-serial-communication-protocol"><a class="header" href="#so-is-uart-a-serial-communication-protocol">So is UART a serial-communication protocol?</a></h3>
<p>Well... The UART is not a communication protocol itself but rather a hardware component or module that facilitates serial communication between devices. You could say that it is circuitry that serves as the underlying hardware mechanism for implementing various communication protocols such as RS-232, RS-485, MIDI, and others</p>
<p>Confusing... right? ha ha. </p>
<h2 id="how-the-uarts-work"><a class="header" href="#how-the-uarts-work">How the UARTs work.</a></h2>
<p>In UART communication, two UARTs communicate directly with each other. The transmitting UART converts parallel data from a controlling device like a CPU into serial form, transmits it in serial to the receiving UART, which then converts the serial data back into parallel data for the receiving device.<br />
Only two wires are needed to transmit data between two UARTs. Data flows from the Tx pin of the transmitting UART to the Rx pin of the receiving UART:</p>
<p><img src="uart_theory/img/comms_between_two_UARTs.png" alt="Alt text" /></p>
<p>UARTs transmit data asynchronously, which means there is no clock signal to synchronize the output of bits from the transmitting UART to the sampling of bits by the receiving UART. Instead of a clock signal, the transmitting UART adds start and stop bits to the data packet being transferred. These bits define the beginning and end of the data packet so the receiving UART knows when to start reading the bits.</p>
<p>When the receiving UART detects a start bit, it starts to read the incoming bits at a specific frequency known as the baud rate (bits per second). Both UARTs must operate at about the same baud rate. The baud rate between the transmitting and receiving UARTs can only differ by about 10% before the timing of bits gets too far off.</p>
<p>So before any data transfer actually happens, the two UARTs must agree on : </p>
<ol>
<li>The Data packet format</li>
<li>The Baud rate (bps)</li>
</ol>
<p><strong>Example Case :</strong></p>
<p><img src="uart_theory/img/uart_connection.png" alt="Alt text" /></p>
<p>The UART that is going to transmit data receives the data from a data bus. The data bus is used to send data to the UART by another device like a CPU, memory, or microcontroller. Data is transferred from the data bus to the transmitting UART in parallel form.<br />
After the transmitting UART gets the parallel data from the data bus, it adds a start bit, a parity bit, and a stop bit, creating the data packet.<br />
Next, the data packet is output serially, bit by bit at the Tx pin. The receiving UART reads the data packet bit by bit at its Rx pin. The receiving UART then converts the data back into parallel form and removes the start bit, parity bit, and stop bits. Finally, the receiving UART transfers the data packet in parallel to the data bus on the receiving end.</p>
<p><strong>If the communication between the two is asynchronous, how do they agree with each other in the first place?</strong></p>
<ol>
<li>
<p><strong>Manual Configuration</strong>: In many systems, the baud rate is manually configured by the user or system designer. This involves setting the baud rate to a specific value (e.g., 9600 bps, 115200 bps) on both the transmitting and receiving UARTs. The configuration is typically done through software or hardware settings.</p>
</li>
<li>
<p><strong>Default Baud Rate:</strong> In some cases, UART devices may have default baud rate settings. If both devices are configured to use the same default baud rate, no additional configuration is necessary.</p>
</li>
<li>
<p><strong>Negotiation</strong>: In more advanced systems, UART devices may support auto-baud detection or negotiation protocols. Auto-baud detection allows a UART receiver to automatically determine the baud rate of incoming data by analyzing the timing of the start bits. This can be useful when the baud rate is not known in advance or may vary.</p>
</li>
<li>
<p><strong>Hardware Handshaking</strong>: In certain situations, UART communication may also involve hardware handshaking signals (such as RTS/CTS - Request to Send/Clear to Send) to coordinate communication between devices. These signals can help ensure that data is only transmitted when the receiving device is ready to receive it, reducing the risk of data loss or corruption.</p>
</li>
</ol>
<h3 id="the-uart-data-packet"><a class="header" href="#the-uart-data-packet">The UART data packet</a></h3>
<p>The format of the data packet needs to be agreed upon by the two communicating UART circuits as earlier mentioned.</p>
<p>The format is typically structured as follows....
<img src="uart_theory/img/data_packet_format.png" alt="Alt text" /></p>
<ul>
<li><strong>Start Bit</strong>: The start bit signals the beginning of the data byte. It is always set to a low voltage level (logic 0). The duration of the start bit is one bit duration, determined by the baud rate.</li>
</ul>
<p>The UART data transmission line is normally held at a high voltage level when it’s not transmitting data. To start the transfer of data, the transmitting UART pulls the transmission line from high to low for one clock cycle. When the receiving UART detects the high to low voltage transition, it begins reading the bits in the data frame at the frequency of the baud rate.</p>
<ul>
<li><strong>Data Bits</strong>: These are the actual bits representing the data being transmitted.<br />
The number of data bits can vary, but common configurations include 7 or 8 bits per data byte. It can be 5 bits up to 8 bits long if a parity bit is used. If no parity bit is used, the data frame can be 9 bits long.</li>
</ul>
<p>The data bits are typically transmitted LSB (Least Significant Bit) first. The duration of each data bit is determined by the baud rate.</p>
<ul>
<li><strong>Parity Bit (Optional)</strong>: The parity bit, if used, is an additional bit for error detection. It can be set to even parity, odd parity, mark parity, space parity, or no parity (none).</li>
</ul>
<p>Parity describes the evenness or oddness of a number. The parity bit is a way for the receiving UART to tell if any data has changed during transmission. Bits can be changed by electromagnetic radiation, mismatched baud rates, or long distance data transfers. After the receiving UART reads the data frame, it counts the number of bits with a value of 1 and checks if the total is an even or odd number. If the parity bit is a 0 (even parity), the 1 bits in the data frame should total to an even number. If the parity bit is a 1 (odd parity), the 1 bits in the data frame should total to an odd number. When the parity bit matches the data, the UART knows that the transmission was free of errors. But if the parity bit is a 0, and the total is odd; or the parity bit is a 1, and the total is even, the UART knows that bits in the data frame have changed.</p>
<ul>
<li><strong>Stop Bit(s)</strong>: The stop bit(s) signal the end of the data byte. Typically, one or two stop bits are used. The stop bit(s) are set to a high voltage level (logic 1). The duration of each stop bit is determined by the baud rate.</li>
</ul>
<h3 id="advantages-of-using-uarts"><a class="header" href="#advantages-of-using-uarts">Advantages of using UARTs</a></h3>
<ul>
<li>Simple, Only uses two wires</li>
<li>Simple, No clock signal is necessary.</li>
<li>Has a parity bit to allow for error checking</li>
<li>It can accomodate custom communication protocols; The structure of the data packet can be changed as long as both sides are set up for it</li>
<li>Well documented and widely used method</li>
</ul>
<h3 id="disadvantages-of-using-uarts"><a class="header" href="#disadvantages-of-using-uarts">Disadvantages of using UARTs</a></h3>
<ul>
<li>The size of the data frame is limited to a maximum of 9 bits.In scenarios where larger data sizes need to be transmitted, the limitation to 9 bits per frame can result in inefficiencies. It may require breaking down larger data sets into multiple frames, which can increase overhead and decrease overall efficiency.</li>
<li>Doesn’t support multiple slave or multiple master systems</li>
<li>The baud rates of each UART must be within 10% of each other</li>
</ul>
<h3 id="clarifications"><a class="header" href="#clarifications">Clarifications</a></h3>
<p>As seen from the image at the top of the page, the connection uses two wires to transmit data between devices. But in practice, you may use 3 wires for each device. For example, the 3 wires attached to UART 1 will be : </p>
<ul>
<li>The Transmitter wire (Tx wire) from UART 1 to UART 2</li>
<li>The Receiver wire (RX) from UART 2 to UART 1</li>
<li>The Ground wire</li>
</ul>
<h3 id="credits-and-references"><a class="header" href="#credits-and-references">credits and references</a></h3>
<ul>
<li>Credits go to this <a href="https://www.circuitbasics.com/basics-uart-communication/">circuitbasics blog</a>, for the images and elaborate content. You can give it a read.</li>
<li>If you want to learn about the different serial communication protocols associated with the UART, this <a href="https://www.raveon.com/wp-content/uploads/2019/01/AN236SerialComm.pdf">Raveon technical brief</a> provides a short overview</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draft_2"><a class="header" href="#draft_2">draft_2</a></h1>
<p>This chapter covers the theory on UART registers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notable-crates"><a class="header" href="#notable-crates">Notable Crates</a></h1>
<h2 id="for-bare-metal-programming"><a class="header" href="#for-bare-metal-programming">For bare metal programming</a></h2>
<ul>
<li>heapless</li>
<li>critical-section</li>
<li>portable-atomic</li>
<li>bit-field, bitfield</li>
<li>bit-flags</li>
<li>embedded-hal</li>
<li>embedded-dma : This library provides the ReadBuffer and WriteBuffer unsafe traits to be used as bounds to buffers types used in DMA operations.</li>
<li>fugi : time crate for embedded systems</li>
<li>nb : Minimal and reusable non-blocking I/O layer</li>
<li>riscv</li>
<li>riscv-rt</li>
<li>volatile-register</li>
<li>vcell : Just like Cell but with volatile read / write operations</li>
</ul>
<h2 id="utility-like"><a class="header" href="#utility-like">Utility-like</a></h2>
<ul>
<li>svd2rust + form + rustfmt</li>
<li>defmt : A highly efficient logging framework that targets resource-constrained devices, like microcontrollers.
Check out the defmt book at https://defmt.ferrous-systems.com for more information about how to use it.</li>
<li>embassy crates</li>
<li>probe crates</li>
<li>clap</li>
<li>ratatui</li>
<li>serde</li>
</ul>
<h3 id="more-tertiary-for-now"><a class="header" href="#more-tertiary-for-now">more tertiary for now</a></h3>
<ul>
<li>cfg-if  : A macro for defining #[cfg] if-else statements.</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-embedded-rust"><a class="header" href="#why-embedded-rust">Why Embedded Rust</a></h1>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety:</a></h2>
<p>Rust's ownership system and borrow checker ensure memory safety without the need for a garbage collector. This helps prevent common issues like null pointer dereferences, buffer overflows, and data races.</p>
<h2 id="concurrency-and-parallelism"><a class="header" href="#concurrency-and-parallelism">Concurrency and Parallelism:</a></h2>
<p>Advantage: Rust provides ownership-based concurrency control, allowing developers to write concurrent code without the risk of data races. The language's emphasis on zero-cost abstractions enables efficient parallelism.</p>
<h2 id="nice-integration-with-c-and-c-and-their-respective-tools"><a class="header" href="#nice-integration-with-c-and-c-and-their-respective-tools">Nice integration with C and C++... and their respective tools</a></h2>
<ul>
<li>Rust has a robust FFI that allows seamless integration with C and C++ code.</li>
<li>Cargo integrates well with tools that are popular in the embedded world, so a C developer needs not learn ALL NEW things. For example the default toolchain components are extended LLVM or GNU components. You can integrate C library and build tools in a seamless manner in your project.</li>
</ul>
<h2 id="ergonomics"><a class="header" href="#ergonomics">Ergonomics</a></h2>
<ul>
<li>Tools are considerably documented.</li>
<li>Helpful community</li>
<li>many helpful tools &amp; crates... especially the compiler itself. </li>
</ul>
<p>Naive but somehow true perspective : Rust enables you to write complex software (even as a junior), your implementation is not 100% dependent on your experience level.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="newlib"><a class="header" href="#newlib">Newlib</a></h3>
<p>Newlib is a lightweight and efficient C library primarily designed for embedded systems and other resource-constrained environments. It provides standard C library functionality, including input/output, string manipulation, memory management, and more, while prioritizing small size and minimal overhead. Although it aims to offer POSIX compatibility, Newlib may not implement the full range of POSIX functions found in larger libraries like glibc. Suitable for standalone usage or integration into embedded development toolchains, Newlib serves as a practical choice for projects where conserving resources is paramount and where comprehensive POSIX compliance is not a strict requirement.</p>
<p><a href="https://sourceware.org/newlib/">newlib official homepage</a></p>
<h3 id="glibc-gnu-c-library"><a class="header" href="#glibc-gnu-c-library">glibc (GNU C Library):</a></h3>
<p>glibc is the standard C library for the GNU operating system and most Linux distributions.<br />
It provides comprehensive POSIX compatibility and a wide range of features, but it is relatively large and may not be suitable for embedded systems with limited resources.</p>
<h3 id="musl-libc"><a class="header" href="#musl-libc">musl libc:</a></h3>
<p>musl is a lightweight, fast, and efficient C library that aims to provide POSIX compatibility with minimal overhead. It is designed to be small and suitable for embedded systems and other resource-constrained environments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
