<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>draft_1 - driver development in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">INTRO</li><li class="chapter-item expanded "><a href="../../../intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../../../intro/prerequisites.html"><strong aria-hidden="true">2.</strong> Prerequisites for the Book</a></li><li class="chapter-item expanded affix "><li class="part-title">UNDERSTANDING DRIVERS (theory)</li><li class="chapter-item expanded "><a href="../../../understanding_drivers/understanding_drivers.html"><strong aria-hidden="true">3.</strong> Intro to Drivers</a></li><li class="chapter-item expanded "><a href="../../../understanding_drivers/controlling_the_device_below.html"><strong aria-hidden="true">4.</strong> Role 1: Controlling the device below</a></li><li class="chapter-item expanded "><a href="../../../understanding_drivers/providing_an_interface.html"><strong aria-hidden="true">5.</strong> Role 2: Providing an interface</a></li><li class="chapter-item expanded "><a href="../../../understanding_drivers/types_of_drivers.html"><strong aria-hidden="true">6.</strong> Types of Drivers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Kernel and Driver Interaction mechanisms</div></li><li class="chapter-item expanded affix "><li class="part-title">BARE METAL PROGRAMMING</li><li class="chapter-item expanded "><a href="../../../bare_metal/the_no_std_preface.html"><strong aria-hidden="true">8.</strong> No std preface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../bare_metal/no_std/the_no_std_intro.html"><strong aria-hidden="true">8.1.</strong> No std</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/no_std/removing_std_lib.html"><strong aria-hidden="true">8.2.</strong> Disabling the Standard Library</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/no_std/pracs_1.html"><strong aria-hidden="true">8.3.</strong> Pracs 1</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/no_std/pracs_2.html"><strong aria-hidden="true">8.4.</strong> Pracs 2</a></li></ol></li><li class="chapter-item expanded "><a href="../../../bare_metal/cross_compilation/cross_compilation.html"><strong aria-hidden="true">9.</strong> Cross-Compilation</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/linking/linking.html"><strong aria-hidden="true">10.</strong> Linking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../bare_metal/linking/rusty_linkers.html"><strong aria-hidden="true">10.1.</strong> Rusty Linkers</a></li></ol></li><li class="chapter-item expanded "><a href="../../../bare_metal/probing/probing_preface.html"><strong aria-hidden="true">11.</strong> Probing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../bare_metal/probing/probing_theory_1.html"><strong aria-hidden="true">11.1.</strong> Probing Theory</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/probing/pracs.html"><strong aria-hidden="true">11.2.</strong> Probing Pracs</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/probing/udev.html"><strong aria-hidden="true">11.3.</strong> udev</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/probing/flashing.html"><strong aria-hidden="true">11.4.</strong> Flashing</a></li><li class="chapter-item expanded "><a href="../../../bare_metal/probing/logging_and_monitoring/monitoring_1.html"><strong aria-hidden="true">11.5.</strong> Monitoring and Logging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../bare_metal/probing/logging_and_monitoring/monitoring_2.html" class="active"><strong aria-hidden="true">11.5.1.</strong> draft_1</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.7.</strong> No-std testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Performance testing</div></li><li class="chapter-item expanded affix "><li class="part-title">ABSTRACTIONS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> MMIO programming</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../registers_and_mmio_programming.html"><strong aria-hidden="true">13.1.</strong> Registers and MMIO programming</a></li></ol></li><li class="chapter-item expanded "><a href="../../../knowing_your_hardware.html"><strong aria-hidden="true">14.</strong> The datasheet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Abstraction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../svd2rust.html"><strong aria-hidden="true">15.1.</strong> svd2rust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">THE UART THEORY</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Understanding UART Theory</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../uart_theory/draft_1.html"><strong aria-hidden="true">16.1.</strong> draft_1</a></li><li class="chapter-item expanded "><a href="../../../uart_theory/draft_2.html"><strong aria-hidden="true">16.2.</strong> draft_2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Understanding UART physical Implemetation in the esp32</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (naive, without async)</li><li class="chapter-item expanded "><a href="../../../uart_implementations/on_qemu/intro.html"><strong aria-hidden="true">18.</strong> tutorial over a naive UART implementation on a Qemu device</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../uart_implementations/on_qemu/setting_things_up.html"><strong aria-hidden="true">18.1.</strong> Setting Things Up</a></li><li class="chapter-item expanded "><a href="../../../uart_implementations/on_qemu/setting_up_the_compiler.html"><strong aria-hidden="true">18.2.</strong> Setting up the compiler</a></li><li class="chapter-item expanded "><a href="../../../uart_implementations/on_qemu/setting_up_LLD_linker.html"><strong aria-hidden="true">18.3.</strong> Setting up the linker</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (less naive, with async)</li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> tutorial over a naive UART implementation on a Qemu device</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">OTHER STORIES</li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Driver Security</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">22.1.</strong> Common Security Issues in Driver Development</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.2.</strong> Rust's Safety Features for Driver Security</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.3.</strong> Best Practices for Secure Driver Development</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Case Studies and Examples</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Real-world Driver Development Examples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Analyzing an Existing Rust Driver</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Iterative Implementation</div></li><li class="chapter-item expanded affix "><li class="part-title">APPENDIX</li><li class="chapter-item expanded "><a href="../../../notable_crates.html"><strong aria-hidden="true">25.</strong> Notable Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Notable Learning Resources</div></li><li class="chapter-item expanded "><a href="../../../why_embedded_rust.html"><strong aria-hidden="true">27.</strong> why use Rust?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Out of topic</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../misc/different_std_libs.html"><strong aria-hidden="true">28.1.</strong> different_std_libs</a></li><li class="chapter-item expanded "><a href="../../../misc/the_C_runtime.html"><strong aria-hidden="true">28.2.</strong> the-C-runtime</a></li><li class="chapter-item expanded "><a href="../../../misc/API.html"><strong aria-hidden="true">28.3.</strong> api-definition</a></li><li class="chapter-item expanded "><a href="../../../misc/abi.html"><strong aria-hidden="true">28.4.</strong> abi-definition</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">driver development in Rust</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustaceansKenya/driver-development-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/RustaceansKenya/driver-development-book/edit/master/driver_book/src/bare_metal/probing/logging_and_monitoring/monitoring_2.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="draft_1"><a class="header" href="#draft_1">draft_1</a></h1>
<!-- undone : Explain this topic well, in a procedural manner. This topic does not have readable flow -->
<p>This page elaborates on the logging architecture.</p>
<h2 id="typical-logging-architecture"><a class="header" href="#typical-logging-architecture">Typical logging architecture</a></h2>
<p>So how does logging happen? How is the log data encoded? How is the data transmitted? How does the host machine receive and display the log data?</p>
<p>Here is a rough architecture....</p>
<p><img src="img/logging_architecture_lvl_0.png" alt="Alt text" /></p>
<p>Well... there's a lot to unpack here.</p>
<h3 id="explanations-based-on-the-image-above"><a class="header" href="#explanations-based-on-the-image-above">Explanations Based on the Image above</a></h3>
<p>Our aim is to :</p>
<ol>
<li>Allow the programmer to embed logging 'print' statements in the code</li>
<li>Make the no-std program have the ability to pass on those log statements to the Serial output of the target chip</li>
<li>Make the host CPU receive those log statements and display them.</li>
<li>(optional) provide an interactive CLI app to help the end-user to engage with the data in an interactive manner.</li>
</ol>
<h3 id="pre-runtime-flow-of-events"><a class="header" href="#pre-runtime-flow-of-events">Pre-runtime flow of events</a></h3>
<p>The programmer embeds log_print macros in their code where necessary. And then they compile it.<br />
For example :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// no_std module
fn _start () {
    // bla bla bla
    log::info!(&quot;program has finished bla-bla-ing&quot;);
     
    if some_variable == true {
        // ble ble ble
        log::warn!(&quot;program has done ble-ble-ble&quot;);
    }
    else {
        // bli bli bli
        log::error!(&quot;program just did bli-bli-bli, that's an error, deal with it&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>During the compilation process, the compiler expands the log_macros seen above in accordance to the log_crate that the programmer is using. So a line like <code>log::info!(&quot;program has finished bla-bla-ing&quot;);</code> will expand to something like :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // code block filled with pseudo-code
  {
    // this code cotains instructions that can indirectly manipulate UART registers
    // It could even be written in assembly, if you want finer control over how the log-info gets to be passed. 
    let uart_instance = acquire_uart();
    uart_instance.uart_write_string (&quot;program has finished bla-bla-ing&quot;);
    uart_instance.flush();

  }
<span class="boring">}</span></code></pre></pre>
<p>Point being, the <code>log macros</code> expand into code that can interact with the serial outout of the SoC. In this case, the macros expand to code that can interact with the UART.</p>
<p><br><br></p>
<p>During that same compilation process, the indices of the <strong>interned strings</strong> get embued as part of the debug section in the final object file.<br />
So what are <strong>interned strings?</strong>.</p>
<p>Well... the micro-controller has limited memory. We would not like to burden it with the responsibility of storing log_strings. We would not like to make the log_strings part of the binary file that gets loaded onto the MCUs memory.<br />
So people found a way to <em>compress</em> the strings. This string compression consists of building a table of string literals, like &quot;program has finished bla-bla-ing&quot; or &quot;The answer is {:?}&quot;, at compile time. At runtime, this table is made accessible for the host machine to view. On the other hand, the target machine sends indices instead of complete strings.</p>
<p>So instead of storing complete strings in the MCU's memory, we store them in the host's memory. The MCU only stores string indices (string IDs).<br />
On top of sparing the MCUs memory, this technique increases the logging throughput; the MCU can use a single byte to convey an entire 256-byte string.</p>
<p>In summary, <strong>Interned strings</strong> are the strings that get indexed in the compression process. Log crates usually store them as debug info in the program's object file.</p>
<h3 id="runtime-flow-of-events"><a class="header" href="#runtime-flow-of-events">Runtime flow of events</a></h3>
<p>These are the events that happen during the actual logging.<br />
Here are the assumption is that...</p>
<ol>
<li>The program is already running in the MCU</li>
<li>The debug info has been loaded in the host machine.</li>
<li>There is a decoder, and printer installed on the host machine.</li>
</ol>
<p>From the above image...<br />
The log_print macros found in the no_std app get executed by the processor of the SoC.<br />
And since those code snippets contain code that manipulates the UART driver, they get used to transmit the indices of the interned strings to the UART.<br />
The data that gets transferred to the UART is <a href="#unformatted-data"><em>unformatted</em></a> .</p>
<p>With the assumption that the HOST machine has USB ports only, we are forced to use a UART-to-USB integrated circuit to convert the UART signals into USB-compatible signals.</p>
<p>The SoC's USB transfers the data to the host's serial input(another USB).</p>
<p><strong>The decoder</strong></p>
<p>The decoder is a program that decodes the indices in the received data. 
The log data received from the SoC contains indices that reference actual strings found in the debug section of the target object file.<br />
The decoder's work is to fetche the respective interned strings from the debug section and resolve/expand all the indices.<br />
The decoder then outputs the complete AND unformatted logs.</p>
<p><strong>The Printer</strong></p>
<p>The printer is a program that ...</p>
<ul>
<li>Takes in unformatted logs and formmats them</li>
<li>Interacts with the host's console in order to output the logs in a presentable way (tables, buttons, percentages... basically a UI)</li>
</ul>
<p>Both the decoder and the printer can be custom-made crates or established third-party software. The choice is up to you.</p>
<h4 id="unformatted-data"><a class="header" href="#unformatted-data">Unformatted data?</a></h4>
<p><em>What is formatting in general?</em></p>
<p>Formatting is the process of converting raw data into another form that is presentable.<br />
For example, you can format a struct to be a string</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is pseudo, no syntax rules have been observed
struct Time {
    year : 2024,
    month : &quot;January&quot;,
    date : ...
    hr... 
    min...
}


fn format ( input: &amp;Time) -&gt; String{
    // outputs a string like ...
    //  &quot;25th January 2024 at 0800hrs&quot;
}
<span class="boring">}</span></code></pre></pre>
<p>So you can say, &quot;the struct <code>Time</code> can be formatted into a string.</p>
<p><em>What is formatting in the logging context?</em></p>
<p>Formatting in the logging context involves ...</p>
<ol>
<li>Converting raw binary data into strings.</li>
<li>Implementing the format styles of respective data.</li>
</ol>
<p>For example :</p>
<pre><code class="language-bash"># Here is a conversion of raw data into strings
`255u8` gets converted into into &quot;255&quot;  

# Here is an implementtion of formatting styles
log::info!(&quot;{=u8:#x}&quot;, 42); will be formatted to the string &quot;0x2a&quot;
log::info!(&quot;{=u8:b}&quot;, 42);  will be formatted to the string &quot;101010&quot;
</code></pre>
<p>The logging data coming out of the SoC is usually unformatted so as to spare the MCU's processor from having to do the conversion/formatting. All the heavy-lifting is made to be the host's resposibility.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../bare_metal/probing/logging_and_monitoring/monitoring_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../registers_and_mmio_programming.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../bare_metal/probing/logging_and_monitoring/monitoring_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../registers_and_mmio_programming.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../../ace.js"></script>
        <script src="../../../editor.js"></script>
        <script src="../../../mode-rust.js"></script>
        <script src="../../../theme-dawn.js"></script>
        <script src="../../../theme-tomorrow_night.js"></script>

        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
