<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>No-std recap - driver development in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">INTRO</li><li class="chapter-item expanded "><a href="../../intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../../intro/prerequisites.html"><strong aria-hidden="true">2.</strong> Prerequisites for the Book</a></li><li class="chapter-item expanded affix "><li class="part-title">UNDERSTANDING DRIVERS (theory)</li><li class="chapter-item expanded "><a href="../../understanding_drivers/understanding_drivers.html"><strong aria-hidden="true">3.</strong> Intro to Drivers</a></li><li class="chapter-item expanded "><a href="../../understanding_drivers/controlling_the_device_below.html"><strong aria-hidden="true">4.</strong> Role 1: Controlling the device below</a></li><li class="chapter-item expanded "><a href="../../understanding_drivers/providing_an_interface.html"><strong aria-hidden="true">5.</strong> Role 2: Providing an interface</a></li><li class="chapter-item expanded "><a href="../../understanding_drivers/types_of_drivers.html"><strong aria-hidden="true">6.</strong> Types of Drivers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Kernel and Driver Interaction mechanisms</div></li><li class="chapter-item expanded affix "><li class="part-title">BARE METAL PROGRAMMING</li><li class="chapter-item expanded "><a href="../../bare_metal/the_no_std_preface.html"><strong aria-hidden="true">8.</strong> No std preface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../bare_metal/no_std/the_no_std_intro.html"><strong aria-hidden="true">8.1.</strong> No std</a></li><li class="chapter-item expanded "><a href="../../bare_metal/no_std/removing_std_lib.html"><strong aria-hidden="true">8.2.</strong> Disabling the Standard Library</a></li><li class="chapter-item expanded "><a href="../../bare_metal/no_std/pracs_1.html"><strong aria-hidden="true">8.3.</strong> Pracs 1</a></li><li class="chapter-item expanded "><a href="../../bare_metal/no_std/pracs_2.html"><strong aria-hidden="true">8.4.</strong> Pracs 2</a></li></ol></li><li class="chapter-item expanded "><a href="../../bare_metal/cross_compilation/cross_compilation.html"><strong aria-hidden="true">9.</strong> Cross-Compilation</a></li><li class="chapter-item expanded "><a href="../../bare_metal/linking/linking.html"><strong aria-hidden="true">10.</strong> Linking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../bare_metal/linking/rusty_linkers.html"><strong aria-hidden="true">10.1.</strong> Rusty Linkers</a></li></ol></li><li class="chapter-item expanded "><a href="../../bare_metal/probing/probing_preface.html"><strong aria-hidden="true">11.</strong> Probing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../bare_metal/probing/probing_theory_1.html"><strong aria-hidden="true">11.1.</strong> Probing Theory</a></li><li class="chapter-item expanded "><a href="../../bare_metal/probing/pracs.html"><strong aria-hidden="true">11.2.</strong> Probing Pracs</a></li><li class="chapter-item expanded "><a href="../../bare_metal/probing/udev.html"><strong aria-hidden="true">11.3.</strong> udev</a></li><li class="chapter-item expanded "><a href="../../bare_metal/probing/flashing.html"><strong aria-hidden="true">11.4.</strong> Flashing</a></li><li class="chapter-item expanded "><a href="../../bare_metal/probing/logging_and_monitoring/monitoring_1.html"><strong aria-hidden="true">11.5.</strong> Monitoring and Logging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../bare_metal/probing/logging_and_monitoring/monitoring_2.html"><strong aria-hidden="true">11.5.1.</strong> draft_1</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.7.</strong> No-std testing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Performance testing</div></li><li class="chapter-item expanded affix "><li class="part-title">ABSTRACTIONS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> MMIO programming</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../registers_and_mmio_programming.html"><strong aria-hidden="true">13.1.</strong> Registers and MMIO programming</a></li></ol></li><li class="chapter-item expanded "><a href="../../knowing_your_hardware.html"><strong aria-hidden="true">14.</strong> The datasheet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Abstraction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../svd2rust.html"><strong aria-hidden="true">15.1.</strong> svd2rust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">THE UART THEORY</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Understanding UART Theory</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../uart_theory/draft_1.html"><strong aria-hidden="true">16.1.</strong> draft_1</a></li><li class="chapter-item expanded "><a href="../../uart_theory/draft_2.html"><strong aria-hidden="true">16.2.</strong> draft_2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Understanding UART physical Implemetation in the esp32</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (Qemu)</li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/intro.html"><strong aria-hidden="true">18.</strong> Intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/setting_things_up.html"><strong aria-hidden="true">18.1.</strong> Setting Things Up</a></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/setting_up_the_compiler.html"><strong aria-hidden="true">18.2.</strong> Setting up the compiler</a></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/writing_a_bare_metal_rust_executable copy.html" class="active"><strong aria-hidden="true">18.3.</strong> No-std recap</a></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/setting_up_qemu.html"><strong aria-hidden="true">18.4.</strong> Setting up the Riscv Virtual environment</a></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/setting_up_LLD_linker.html"><strong aria-hidden="true">18.5.</strong> Setting up the linker</a></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/setting_up_build_automation.html"><strong aria-hidden="true">18.6.</strong> Automating build & run</a></li></ol></li><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/loaders_and_bootloaders/intro.html"><strong aria-hidden="true">19.</strong> Loaders and Bootloaders</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../uart_implementations/on_qemu/loaders_and_bootloaders/bootloader.html"><strong aria-hidden="true">19.1.</strong> The Bootloader</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">THE UART IMPLEMENTATION (less naive, with async)</li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> tutorial over a naive UART implementation on a Qemu device</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> tutorial over a naive UART implementation on a Esp32 device</div></li><li class="chapter-item expanded affix "><li class="part-title">OTHER STORIES</li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Driver Security</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Common Security Issues in Driver Development</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Rust's Safety Features for Driver Security</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.3.</strong> Best Practices for Secure Driver Development</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Case Studies and Examples</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">24.1.</strong> Real-world Driver Development Examples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.2.</strong> Analyzing an Existing Rust Driver</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Iterative Implementation</div></li><li class="chapter-item expanded affix "><li class="part-title">APPENDIX</li><li class="chapter-item expanded "><a href="../../notable_crates.html"><strong aria-hidden="true">26.</strong> Notable Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Notable Learning Resources</div></li><li class="chapter-item expanded "><a href="../../why_embedded_rust.html"><strong aria-hidden="true">28.</strong> why use Rust?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Out of topic</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../misc/different_std_libs.html"><strong aria-hidden="true">29.1.</strong> different_std_libs</a></li><li class="chapter-item expanded "><a href="../../misc/the_C_runtime.html"><strong aria-hidden="true">29.2.</strong> the-C-runtime</a></li><li class="chapter-item expanded "><a href="../../misc/API.html"><strong aria-hidden="true">29.3.</strong> api-definition</a></li><li class="chapter-item expanded "><a href="../../misc/abi.html"><strong aria-hidden="true">29.4.</strong> abi-definition</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">driver development in Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustaceansKenya/driver-development-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/RustaceansKenya/driver-development-book/edit/master/driver_book/src/uart_implementations/on_qemu/writing_a_bare_metal_rust_executable copy.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="recap-on-writing-a-bare_metal_rust_executable"><a class="header" href="#recap-on-writing-a-bare_metal_rust_executable">Recap on writing a bare_metal_rust_executable</a></h1>
<h2 id="1-no_std"><a class="header" href="#1-no_std">1. NO_STD</a></h2>
<p>A bare metal executable is a rust program that can run on a piece of hardware without needing an operating system.</p>
<p>Since we are building a driver, we need to write it as a program that is not dependent on an operating system.<br />
Normal Rust programs depend on the rust standard library. The Rust standard library itself contains functions that call OS-specific system calls. So we cannot use the Rust std library.</p>
<p>We use the core Rust Library which is not environment-specific. The core library is dependency-free. It's only requirement is that the programmer provides the definitions of some linker symbols and language items. </p>
<p>To disable the std-dependence, we add the crate attribute <code>#![no_std]</code> to our project. </p>
<h2 id="2-no_main"><a class="header" href="#2-no_main">2. NO_MAIN</a></h2>
<p>Libc is a common C standard library that has been in use for a long time. It has been implemented for very many operating systems.<br />
Rust is a new language. It is very hard to implement the rust_std for all operating systems. To save on labour and allow compatibility, Rust creators decided to make the Rust Library to use libC functions instead of recreating the functions in pure Rust. Though there are some parts of the Rust std library that do not depend on libc.</p>
<p>Now that it is clear that rust_std depends on libc, when a rust bin is executed, the following events happen.</p>
<ol>
<li>The executable program is stored in the main memory (eg RAM)</li>
<li>The CPU points to the first instruction of the executable (the entry point). In this case, the entry point is the <code>_start</code> function found in the C runtime.</li>
<li>The C runtime sets up its environment in preparation for the libc functions that will get called by the rust_std functions</li>
<li>After the C runtime has set up the execution environment for the libc functions, it points to the entry point of the Rust Runtime.</li>
<li>The entry point of the Rust Runtime is marked with a language item called &quot;start&quot; ie [start]</li>
<li>So the Rust runtime creates an executable environment for executing the Rust functions.</li>
<li>After the Rust runtime has finished setting up things, it looks for the &quot;main&quot; function.</li>
<li>Main starts executing</li>
</ol>
<p>Our bare metal program does not depend on the C runtime. So this sequence of events is quite irrelevant to us.<br />
What we will do is that we will inform the compiler that we wont follow this sequence by : </p>
<ol>
<li>Adding the <code>#![no_main]</code> crate attribute to our project.</li>
<li>Declaring our own entry point function</li>
</ol>
<p>To declare our own entry point, we will export a function out of the crate... like so :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle] // The no_mangle attribute explained below
pub extern &quot;C&quot; fn _start()

// Mangling is a technique used by compilers to encode the names of 
// functions, methods, and other symbols in a program in a way that includes additional information beyond just the name itself. 

// For example `main` may become `main21212jxbjbjbkjckbdsc&amp;kbjbjksdbdjkbf`
// The primary purpose of mangling is to make sure that each variable or function is completely unique to
// the point that there are no name-conflicts during compilation and linking.  
// This also enables function overloading 

//In Rust, the #[no_mangle] attribute is used to instruct the compiler not to mangle the name of the item ...
// (function or static variable) during compilation. This is useful when you want to interface with external
//  code, like C code or assembly code, where the function names need to remain unchanged.  

// We want &quot;_start&quot; to be referenced as it is. We cannot gamble with the identity such a symbol name
<span class="boring">}</span></code></pre></pre>
<p>But that is not enough, we need to tell the linker the name of our entry_point function. We do this by writing a linker script that uses the <code>ENTRY</code> command.<br />
The linker will place the code as the first part of the .text section and update the elf header sections to reflect this info.</p>
<pre><code class="language-lds">...
OUTPUT_ARCH( &quot;riscv&quot; )


ENTRY( _start )  /* See? we have used the name `_start` just like it is. If name mangling had happened, we would have had some random name that changes with every compilation.  

MEMORY
{
  ram : ORIGIN = 0x80000000, LENGTH = 128M
}
</code></pre>
<h2 id="3-panic-handler"><a class="header" href="#3-panic-handler">3. Panic Handler</a></h2>
<p>Rust runtime panics when a violation happens. Rust requires you to define a function that will always get called after a panic happens.<br />
That function is tagged by the #[panic_handler] attribute.</p>
<p>The panic_handler function never returns anything, it diverges. It is therefore a divergent function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::panic::PanicInfo;
#[panic_handler]
fn my_custom_function( panic_info: &amp;PanicInfo)-&gt; !{
    println!(&quot;message : {}&quot;, panic_info.message())
    println!(&quot;location : {}&quot;, panic_info.location())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="4-the-eh_personality--aka-error_handling-personality"><a class="header" href="#4-the-eh_personality--aka-error_handling-personality">4. The eh_personality  (aka error_handling personality)</a></h2>
<p>Rust requires you to define a function that will always get called when it wants to unwind and free a stack.<br />
This function is tagged with #[eh_personality] attribute.</p>
<p>When a panic happens, the program stops (theoretically). The program can decide to free the stack or just abort and let the underlying OS clear the stack.<br />
The thing is, to clear the stack, you have to unwind it. To unwind the stack, you have to use some hard functions...Functions that depend on some OS functionalities. This is a chicken-egg problem.</p>
<p>So we resort to aborting.</p>
<p>To specify this behaviour, you can tweak the cargo file as follows : </p>
<pre><code class="language-toml">[profile.release]
panic = &quot;abort&quot;

[profile.dev]
panic = &quot;abort&quot;
</code></pre>
<p>By default the settings are usually :</p>
<pre><code class="language-toml">[profile.release]
panic = &quot;unwind&quot;

[profile.dev]
panic = &quot;unwind&quot;
</code></pre>
<p>Now, the #[eh_personality] tag is a tag that is pegged to the function that gets called when a rust program wants to unwind its stack. eg</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[eh_personality]
fn custom_unwind(){
    // do some unwinding statements ... MAgiC!
}
<span class="boring">}</span></code></pre></pre>
<p>BUT since we have specified that our program will always abort... AND that it will never call the unwind function, we are no longer required to define the unwinding function</p>
<h2 id="5-compile-for-a-bare_metal-target"><a class="header" href="#5-compile-for-a-bare_metal-target">5. Compile for a bare_metal target</a></h2>
<p>You can now compile for the speific target that you want. In our case, it is the <code>riscv64-unknown-none-elf</code>.<br />
To get a recap on how to perform cross-compiltion, re-visit <a href="../../bare_metal/cross_compilation/cross_compilation.html">this chapter</a></p>
<h2 id="template-link"><a class="header" href="#template-link">Template Link</a></h2>
<p>You can view the template folder <a href="https://github.com/RustaceansKenya/driver-development-book/tree/master/chapter_snapshots/_0_bare">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../uart_implementations/on_qemu/setting_up_the_compiler.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../uart_implementations/on_qemu/setting_up_qemu.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../uart_implementations/on_qemu/setting_up_the_compiler.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../uart_implementations/on_qemu/setting_up_qemu.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
